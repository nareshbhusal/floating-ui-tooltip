{"version":3,"file":"index.js","sources":["../src/tooltip-element.ts","../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","../src/floating-ui-tooltip.ts","../src/defaultProps.ts","../src/index.ts","../src/addCSS.ts","../src/debounce.ts"],"sourcesContent":["const NODE_CLASSNAME_PREFIX = 'floating-ui-tooltip';\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nconst createTooltipElement = (): HTMLElement => {\n\n  const tooltipRoot = div();\n  const tooltipBox = div();\n  const tooltipContent = div();\n  const arrowElement = div();\n\n  tooltipRoot.className = `${NODE_CLASSNAME_PREFIX}-root`;\n  tooltipBox.className = `${NODE_CLASSNAME_PREFIX}-box`;\n  tooltipContent.className = `${NODE_CLASSNAME_PREFIX}-content`;\n  arrowElement.className = `${NODE_CLASSNAME_PREFIX}-arrow`;\n\n  tooltipBox.appendChild(tooltipContent);\n  tooltipBox.appendChild(arrowElement);\n  tooltipRoot.appendChild(tooltipBox);\n\n  tooltipContent.innerHTML = `\n    <div id=\"tooltip-container\">\n    <h3>Default tooltip</h3>\n    </div>\n  `;\n\n  tooltipBox.setAttribute('role', 'tooltip');\n  tooltipRoot.setAttribute('data-state', '');\n  Object.assign(tooltipRoot.style, {\n    visibility: 'hidden',\n    left: `0px`,\n    top: `0px`\n  });\n  return tooltipRoot;\n}\n\n\nexport interface TooltipElementChildren {\n  box: HTMLDivElement;\n  content: HTMLDivElement;\n  arrow: HTMLDivElement;\n}\n\nexport function getChildren(tooltipElement: Element): TooltipElementChildren {\n  return {\n    box: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-box`)!,\n    content: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-content`)!,\n    arrow: <HTMLDivElement>tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-arrow`) || undefined\n  };\n}\n\nexport default createTooltipElement;\n","function getSide(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === 'x';\n  let coords;\n\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  const skippedMiddlewareNames = new Set();\n  let _debug_loop_count_ = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _debug_loop_count_++;\n\n      if (_debug_loop_count_ > 100) {\n        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));\n      }\n    }\n\n    const {\n      name,\n      fn\n    } = middleware[i];\n\n    if (skippedMiddlewareNames.has(name)) {\n      continue;\n    }\n\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: { ...middlewareData[name],\n        ...data\n      }\n    };\n\n    if (reset) {\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n\n        if (reset.skip !== false) {\n          skippedMiddlewareNames.add(name);\n        }\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(middlewareArguments, options) {\n  var _await$platform$isEle;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary\n  }));\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n    strategy\n  }) : rects[elementContext]); // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getMainAxisFromPlacement(placement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside of the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    return {\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const alignment = getAlignment(placement);\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-start\", side + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;\n      const currentPlacement = placements[currentIndex];\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            skip: false,\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            skip: false,\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      return {\n        reset: {\n          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement\n        }\n      };\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const side = getSide(placement);\n      const isBasePlacement = side === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip2;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              skip: false,\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$slice$;\n\n              const placement = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0) - b.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        return {\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (_temp) {\n  let {\n    strategy = 'referenceHidden',\n    ...detectOverflowOptions\n  } = _temp === void 0 ? {} : _temp;\n  return {\n    name: 'hide',\n\n    async fn(middlewareArguments) {\n      const {\n        rects\n      } = middlewareArguments;\n\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(middlewareArguments, { ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n\n        default:\n          {\n            return {};\n          }\n      }\n    }\n\n  };\n};\n\nfunction convertValueToCoords(placement, rects, value, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getMainAxisFromPlacement(placement) === 'x';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  let crossAxisMulti = 1;\n\n  if (alignment === 'end') {\n    crossAxisMulti = -1;\n  }\n\n  if (rtl && isVertical) {\n    crossAxisMulti *= -1;\n  }\n\n  const rawValue = typeof value === 'function' ? value({ ...rects,\n    placement\n  }) : value;\n  const {\n    mainAxis,\n    crossAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    ...rawValue\n  };\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const diffCoords = convertValueToCoords(placement, rects, value, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getSide(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      let heightSide;\n      let widthSide;\n\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        height: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        width: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      apply == null ? void 0 : apply({ ...dimensions,\n        ...rects\n      });\n      return {\n        reset: {\n          rects: true\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n      const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),\n        strategy\n      }) : rects.reference);\n      const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      return {\n        reset: {\n          rects: await platform.getElementRects({\n            reference: {\n              getBoundingClientRect\n            },\n            floating: elements.floating,\n            strategy\n          })\n        }\n      };\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return (value == null ? void 0 : value.toString()) === '[object Window]';\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  return {\n    width: clientRect.width / scaleX,\n    height: clientRect.height / scaleY,\n    top: clientRect.top / scaleY,\n    right: clientRect.right / scaleX,\n    bottom: clientRect.bottom / scaleY,\n    left: clientRect.left / scaleX,\n    x: clientRect.left / scaleX,\n    y: clientRect.top / scaleY\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isWindow(element)) {\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n\n    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getNearestOverflowAncestor(node) {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isOverflowElement(node)) {\n    return node;\n  }\n\n  return getNearestOverflowAncestor(getParentNode(node));\n}\n\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getOverflowAncestors(getParentNode(target)));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element) {\n  const clientRect = getBoundingClientRect(element);\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingAncestor(element, clippingParent) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping ancestor\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingAncestors(element) {\n  const clippingAncestors = getOverflowAncestors(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingAncestors.filter(clippingAncestors => isElement(clippingAncestors) && contains(clippingAncestors, clipperElement) && getNodeName(clippingAncestors) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors\n\n\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary\n  } = _ref;\n  const mainClippingAncestors = boundary === 'clippingAncestors' ? getClippingAncestors(element) : [].concat(boundary);\n  const clippingAncestors = [...mainClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  getClientRects: element => Array.from(element.getClientRects()),\n  isRTL: element => getComputedStyle$1(element).direction === 'rtl'\n};\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize: _ancestorResize = true,\n    elementResize: _elementResize = true,\n    animationFrame = false\n  } = options;\n  let cleanedUp = false;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestorResize = _ancestorResize && !animationFrame;\n  const elementResize = _elementResize && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...(isElement(reference) ? getOverflowAncestors(reference) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  let observer = null;\n\n  if (elementResize) {\n    observer = new ResizeObserver(update);\n    isElement(reference) && observer.observe(reference);\n    observer.observe(floating);\n  }\n\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n\n  if (animationFrame) {\n    frameLoop();\n  }\n\n  function frameLoop() {\n    if (cleanedUp) {\n      return;\n    }\n\n    const nextRefRect = getBoundingClientRect(reference);\n\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n\n  return () => {\n    var _observer;\n\n    cleanedUp = true;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { autoUpdate, computePosition, getOverflowAncestors };\n","import {\n  computePosition,\n  size,\n  flip,\n  shift,\n  offset,\n  arrow,\n  autoPlacement,\n  hide,\n} from '@floating-ui/dom';\nimport { getChildren } from './tooltip-element';\nimport { Props, TooltipState } from './types';\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 2;\nconst DEFAULT_TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * DEFAULT_TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\nconst floatingUITooltip = async (\n  tooltipProps: Props,\n  tooltipElement: HTMLElement,\n  target: HTMLElement,\n  toHide: boolean,\n  newlyShown: boolean,\n  setShowState: (state: Partial<TooltipState>)=> void\n) => {\n const { toFlip=false, toShift=true } = {};\n\n  const {\n    placement: passedPlacement,\n    hideOnReferenceHidden,\n    offset: passedOffset,\n    hideOnTooltipEscape,\n    arrowSizeScale,\n    resetPlacementOnUpdate\n  } = tooltipProps;\n  console.log(passedPlacement !== 'auto' && toFlip)\n\n  const { box, content, arrow: arrowElement } = getChildren(tooltipElement);\n  const TIP_SIZE = arrowSizeScale * DEFAULT_TIP_SIZE\n\n  // NOTE: autoPlacement changes the placement on every update\n\n  if(!target) return;\n  const computePositionConfig = {\n    middleware: [\n      offset({\n        mainAxis: passedOffset[0],\n        crossAxis: passedOffset[1]\n      }),\n      ...passedPlacement === 'auto' && (newlyShown || resetPlacementOnUpdate) ? [\n        autoPlacement(),\n      ]: [],\n      ...toShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...(passedPlacement !== 'auto' && toFlip) ? [\n        flip({\n          fallbackPlacements: ['right', 'left'],\n          fallbackStrategy: 'initialPlacement' // or `bestFit` (when no placement fits perfectly)\n        })\n      ]: [],\n      arrow({\n        element: arrowElement,\n        padding: TIP_EDGE_MARGIN,\n      }),\n      size({\n        apply({width, height, reference, floating}) {\n        }\n      }),\n      hide()\n    ]\n  }\n\n  if (passedPlacement !== 'auto') {\n    computePositionConfig['placement'] = passedPlacement;\n  }\n\n  const fui = await computePosition(target, tooltipElement, computePositionConfig);\n  const { x, y, placement, middlewareData } = fui;\n\n  const { referenceHidden, escaped } = middlewareData.hide!;\n  /* console.log(`is hidden: ${referenceHidden || toHide}`)\n  console.log(middlewareData)\n  console.log(middlewareData.hide)\n  console.log(middlewareData.shift)\n  console.log(middlewareData.arrow)\n\n  console.log(middlewareData.hide!.escapedOffsets);\n  console.log(middlewareData.hide!.referenceHiddenOffsets);\n\n  console.log('----------------');\n  console.log('\\n\\n\\n') */\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n  const arrowOffCenter = middlewareData.arrow!.centerOffset !== 0;\n\n  const visibility = ((\n    hideOnReferenceHidden && referenceHidden)\n    || (hideOnTooltipEscape && escaped)\n    || toHide) ? 'hidden' : 'visible';\n\n  tooltipElement.setAttribute('data-state', visibility);\n\n  setShowState({\n    isShown: visibility === 'visible',\n    fui\n  });\n\n  Object.assign(tooltipElement.style, {\n    visibility,\n    left: `${x}px`,\n    top: `${y}px`\n  });\n\n  const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n  let staticSideTipSizeMultiplier: string | number = 0;\n  let top: string | number = 0;\n  let left: string | number = 0;\n  left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n  switch(staticSide) {\n    case 'top':\n      staticSideTipSizeMultiplier = 1/1.7;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'bottom':\n      staticSideTipSizeMultiplier = 1/2;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'left':\n      staticSideTipSizeMultiplier = 0.005;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n    case 'right':\n      staticSideTipSizeMultiplier = 1.2;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n  }\n\n  top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n  top = arrowY !== null ? `${arrowY}px` : \"\";\n  Object.assign(arrowElement.style, {\n    visibility: arrowOffCenter ? 'hidden' : 'visible',\n    left,\n    top,\n    right: \"\",\n    bottom: \"\",\n    [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n  });\n\n  return fui;\n}\n\nexport default floatingUITooltip;\n","const defaultProps = {\n  allowHTML: true,\n  content: '',\n  transitionDuration: [300, 250],\n  offset: [10, 0],\n  hideOnClick: true,\n  placement: 'top',\n  resetPlacementOnUpdate: false,\n  hideOnTooltipEscape: true,\n  hideOnReferenceHidden: true,\n  maxWidth: 350,\n  updateDebounce: 100,\n  zIndex: 9999,\n  arrowSizeScale: 1,\n  updateOnEvents: 'resize scroll'\n}\n\nexport default defaultProps;\n","import createTooltipElement, { getChildren } from './tooltip-element';\nimport addCSS from './addCSS';\nimport { Props, TooltipState, Instance } from './types';\nimport floatingUITooltip from './floating-ui-tooltip';\nimport defaultProps from './defaultProps';\nimport debounce from './debounce';\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: Ability to import js bundle without the css\n// NOTE: Should the tooltip be appended to the body?\n// -- https://web.archive.org/web/20210827084020/https://atfzl.com/don-t-attach-tooltips-to-document-body\n\nclass Tooltip {\n  readonly props: Props;\n  readonly reference: HTMLElement;\n  private tooltipElement!: HTMLElement;\n  private state: TooltipState = {\n    isShown: false,\n    isRemoved: false,\n    fui: undefined\n  }\n  private autoUpdateCleanup!: () => void;\n  private toHideTooltip: boolean = false;\n  private debouncedUpdate!: (arg: boolean | undefined) => void;\n\n  constructor(props: Props, target: HTMLElement) {\n    this.props = props;\n    this.reference = target;\n    addCSS();\n  }\n\n  private hookEventListeners() {\n    this.debouncedUpdate = debounce(\n      this.update.bind(this),\n      this.props.updateDebounce\n    );\n    this.autoUpdateCleanup = autoUpdate(\n      this.reference,\n      this.tooltipElement,\n      () => this.debouncedUpdate(undefined)\n    );\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.addEventListener(\n        <keyof WindowEventMap>event,\n        () => this.debouncedUpdate(undefined) as unknown as EventListenerOrEventListenerObject\n      );\n    });\n  }\n\n  public async create() {\n    const toHide = false;\n    this.tooltipElement = createTooltipElement();\n    this.tooltipElement.style.transitionDuration = this.props.transitionDuration[0];\n    const { content: contentBox } = getChildren(this.tooltipElement);\n    const { allowHTML, content } = this.props;\n    if (allowHTML) {\n      contentBox.innerHTML = content;\n    } else {\n      contentBox.innerText = `${content}`;\n    }\n    window['getChildren'] = getChildren;\n\n    console.log(this.tooltipElement);\n\n    document.body.appendChild(this.tooltipElement);\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      true,\n      this.setState.bind(this),\n    );\n    this.hookEventListeners();\n  }\n\n  public getState() {\n    return this.state;\n  }\n\n  private setState(newState: Partial<TooltipState>) {\n    this.state = {\n      ...this.state,\n      ...newState\n    }\n  }\n\n  public async update(toHide?: boolean) {\n    toHide = toHide || this.toHideTooltip || false;\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      false,\n      this.setState.bind(this)\n    );\n  }\n  public hide() {\n    // hide() when tooltip is already hidden should prevent event listeners\n    // from showing tooltip without before running show() manually\n    this.toHideTooltip = true;\n    this.update(true);\n    this.tooltipElement.style.transitionDuration = this.props.transitionDuration[0];\n  }\n\n  public show() {\n    this.toHideTooltip = false;\n    this.update(false);\n    this.tooltipElement.style.transitionDuration = this.props.transitionDuration[1];\n  }\n\n  public remove() {\n    this.tooltipElement.remove();\n    this.state = {\n      isShown: false,\n      isRemoved: true,\n      fui: undefined\n    }\n    this.autoUpdateCleanup();\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.removeEventListener(\n        <keyof WindowEventMap>event,\n        this.debouncedUpdate as unknown as EventListenerOrEventListenerObject\n      );\n    });\n  }\n}\n\nasync function createTooltip(\n  reference: HTMLElement,\n  props: Partial<Props>\n) {\n  const placement = props.placement || defaultProps.placement;\n  const transitionDuration = props.transitionDuration || defaultProps.transitionDuration;\n  const offset = props.offset || defaultProps.offset;\n\n  const allProps: Props = {\n    ...defaultProps,\n    ...props,\n    placement: <Props['placement']>placement,\n    transitionDuration: <Props['transitionDuration']>transitionDuration,\n    offset: <Props['offset']>offset,\n  };\n  const tooltipInstance = new Tooltip(allProps, reference);\n  await tooltipInstance.create();\n\n  const instance: Instance = {\n    props: tooltipInstance.props,\n    reference: tooltipInstance.reference,\n    getState: tooltipInstance.getState.bind(tooltipInstance),\n    show: tooltipInstance.show.bind(tooltipInstance),\n    hide: tooltipInstance.hide.bind(tooltipInstance),\n    remove: tooltipInstance.remove.bind(tooltipInstance),\n  }\n\n  return instance;\n}\n\nexport default createTooltip;\n","import css from './css/style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n"],"names":["div","document","createElement","getChildren","tooltipElement","box","querySelector","content","arrow","undefined","getSide","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","rtl","reference","floating","commonX","x","width","commonY","y","height","mainAxis","length","commonAlign","isVertical","coords","getSideObjectFromPadding","padding","top","right","bottom","left","expandPaddingObject","rectToClientRect","rect","async","detectOverflow","middlewareArguments","options","_await$platform$isEle","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","min","Math","max","within","min$1","value","max$1","name","arrowDimensions","getDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","clientHeight","clientWidth","centerToReference","center","offset","data","centerOffset","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","alignment","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","sides","allPlacements","reduce","acc","side","concat","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_placementsSortedByLe","middlewareData","allowedPlacements","autoAlignment","detectOverflowOptions","placements","filter","getPlacementList","overflow","currentIndex","index","currentPlacement","isRTL","reset","skip","currentOverflows","allOverflows","overflows","nextPlacement","placementsSortedByLeastOverflow","slice","sort","a","b","placementThatFitsOnAllSides","find","every","flip","_middlewareData$flip","initialPlacement","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","oppositePlacement","getExpandedPlacements","overflowsData","push","_middlewareData$flip$","_middlewareData$flip2","nextIndex","resetPlacement","_overflowsData$slice$","getSideOffsets","isAnySideFullyClipped","some","hide","_temp","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","diffCoords","mainAxisMulti","crossAxisMulti","rawValue","convertValueToCoords","size","apply","heightSide","widthSide","xMin","xMax","yMin","yMax","dimensions","isWindow","toString","getWindow","node","window","ownerDocument","defaultView","getComputedStyle$1","getComputedStyle","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","Element","isShadowRoot","ShadowRoot","isOverflowElement","overflowX","overflowY","test","isTableElement","isContainingBlock","isFirefox","navigator","userAgent","css","transform","perspective","contain","willChange","round","getBoundingClientRect","includeScale","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","Node","documentElement","getNodeScroll","scrollLeft","pageXOffset","scrollTop","pageYOffset","getWindowScrollBarX","getRectRelativeToOffsetParent","isOffsetParentAnElement","isScaled","scroll","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","currentNode","getContainingBlock","getNearestOverflowAncestor","body","getOverflowAncestors","list","_node$ownerDocument","scrollableAncestor","isBody","win","target","visualViewport","updatedList","getClientRectFromClippingAncestor","clippingParent","html","abs","innerWidth","scale","offsetLeft","offsetTop","getViewportRect","getInnerBoundingClientRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getDocumentRect","getClippingAncestors","clippingAncestors","clipperElement","parent","child","rootNode","getRootNode","contains","next","firstClippingAncestor","clippingRect","accRect","clippingAncestor","getElementRects","getClientRects","Array","from","computePosition","config","middleware","statefulPlacement","skippedMiddlewareNames","Set","i","fn","has","nextX","nextY","add","computePosition$1","TIP_SIDES_MAP","floatingUITooltip","tooltipProps","toHide","newlyShown","setShowState","toFlip","_b","_a","toShift","_c","passedPlacement","hideOnReferenceHidden","passedOffset","hideOnTooltipEscape","arrowSizeScale","resetPlacementOnUpdate","console","log","_d","arrowElement","TIP_SIZE","computePositionConfig","limiter","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","fui","_g","_e","arrowX","arrowY","arrowOffCenter","visibility","setAttribute","isShown","Object","assign","style","staticSide","staticSideTipSizeMultiplier","defaultProps","allowHTML","transitionDuration","hideOnClick","maxWidth","updateDebounce","zIndex","updateOnEvents","props","defaultStyle","this","isRemoved","type","textContent","head","appendChild","Tooltip","ms","timeout","debouncedUpdate","update","bind","arg","clearTimeout","setTimeout","autoUpdateCleanup","ancestorScroll","_ancestorScroll","ancestorResize","_ancestorResize","elementResize","_elementResize","animationFrame","cleanedUp","ancestors","forEach","ancestor","addEventListener","passive","frameId","observer","ResizeObserver","observe","prevRefRect","frameLoop","nextRefRect","requestAnimationFrame","_observer","removeEventListener","disconnect","cancelAnimationFrame","autoUpdate","_this","event","tooltipRoot","tooltipBox","tooltipContent","className","NODE_CLASSNAME_PREFIX","innerHTML","contentBox","innerText","setState","hookEventListeners","state","newState","toHideTooltip","remove","allProps","tooltipInstance","create","getState","show"],"mappings":"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"}