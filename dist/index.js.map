{"version":3,"file":"index.js","sources":["../src/tooltip-element.ts","../src/utils.ts","../src/floating-ui-tooltip.ts","../src/defaultProps.ts","../src/debounce.ts","../src/index.ts","../src/addCSS.ts"],"sourcesContent":["export const NODE_CLASSNAME_PREFIX = 'floating-ui-tooltip';\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nconst createTooltipElement = (): HTMLDivElement => {\n\n  const tooltipRoot = div();\n  const tooltipBox = div();\n  const tooltipContent = div();\n  const arrowElement = div();\n\n  tooltipRoot.className = `${NODE_CLASSNAME_PREFIX}-root`;\n  tooltipBox.className = `${NODE_CLASSNAME_PREFIX}-box`;\n  tooltipContent.className = `${NODE_CLASSNAME_PREFIX}-content`;\n  arrowElement.className = `${NODE_CLASSNAME_PREFIX}-arrow`;\n\n  tooltipBox.appendChild(tooltipContent);\n  tooltipBox.appendChild(arrowElement);\n  tooltipRoot.appendChild(tooltipBox);\n\n  tooltipContent.innerHTML = `\n    <div id=\"tooltip-container\">\n    <h3>Default tooltip</h3>\n    </div>\n  `;\n\n  tooltipBox.setAttribute('role', 'tooltip');\n  tooltipRoot.setAttribute('data-state', '');\n  Object.assign(tooltipRoot.style, {\n    visibility: 'hidden',\n    left: `0px`,\n    top: `0px`\n  });\n  return tooltipRoot;\n}\n\n\nexport interface TooltipElementChildren {\n  box: HTMLDivElement;\n  content: HTMLDivElement;\n  arrow: HTMLDivElement;\n}\n\nexport function getChildren(tooltipElement: Element): TooltipElementChildren {\n  return {\n    box: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-box`)!,\n    content: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-content`)!,\n    arrow: <HTMLDivElement>tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-arrow`) || undefined\n  };\n}\n\nexport default createTooltipElement;\n","\nexport function doesElementHasTransition(element: HTMLElement): boolean {\n    function getCSSPropertyValue(element: HTMLElement, property: string): string {\n        // not working with firefox, pulling property `transition`\n        return window.getComputedStyle(element).getPropertyValue(property);\n    }\n    const transitionDuration = getCSSPropertyValue(element, \"transition-duration\");\n    return !(transitionDuration === \"0s\" || transitionDuration === \"0ms\");\n}\n\nexport function updateTransitionEndListener(\n  root: HTMLDivElement,\n  action: 'add' | 'remove',\n  listener: (event: TransitionEvent) => void\n): void {\n  const method = `${action}EventListener` as\n  | 'addEventListener'\n  | 'removeEventListener';\n\n  // some browsers apparently support `transition` (unprefixed) but only fire\n  // `webkitTransitionEnd`...\n  [\n    'transitionend',\n    'webkitTransitionEnd',\n    'oTransitionEnd'\n  ].forEach((event) => {\n    root[method](event, listener as EventListener);\n  });\n}\n\nexport function onTransitionEnd(element: HTMLDivElement, callback: Function) {\n\n    function listener(e) {\n      if(e.target === element) {\n        updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n        callback();\n        console.log(\"transition end for event \"+ e);\n      }\n    }\n    // TODO: Any way to get list of event listeners attached to an element?\n    // TODO: Any way to run the callback only once, because all of the events fire apprently\n    updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n    updateTransitionEndListener(<HTMLDivElement>element, 'add', listener);\n}\n\nexport function scrollElementIntoView(element: HTMLElement) {\n  element.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  });\n}\n","import {\n  computePosition,\n  size,\n  flip,\n  shift,\n  offset,\n  arrow,\n  autoPlacement,\n  hide,\n} from '@floating-ui/dom';\nimport { getChildren } from './tooltip-element';\nimport { Props, TooltipState } from './types';\nimport { scrollElementIntoView } from './utils';\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 2;\nconst DEFAULT_TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * DEFAULT_TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\nconst floatingUITooltip = async (\n  tooltipProps: Props,\n  tooltipElement: HTMLElement,\n  target: HTMLElement,\n  toHide: boolean,\n  newlyShown: boolean,\n  setState: (state: Partial<TooltipState>)=> void\n) => {\n const { toFlip=false, toShift=true } = {};\n\n  const {\n    placement: passedPlacement,\n    hideOnReferenceHidden,\n    offset: passedOffset,\n    hideOnTooltipEscape,\n    arrowSizeScale,\n    resetPlacementOnUpdate,\n    arrow: toShowArrow,\n    scrollIntoView\n  } = tooltipProps;\n\n  const { box, content, arrow: arrowElement } = getChildren(tooltipElement);\n  const TIP_SIZE = arrowSizeScale * DEFAULT_TIP_SIZE\n\n  if(!target) return;\n\n  const toEnableAutoPlacement = passedPlacement === 'auto' && (newlyShown || resetPlacementOnUpdate);\n  const toEnableFlip = (passedPlacement !== 'auto' && toFlip);\n  const toEnableShift = toShift && newlyShown;\n\n  const computePositionConfig = {\n    middleware: [\n      offset({\n        mainAxis: passedOffset[0],\n        crossAxis: passedOffset[1]\n      }),\n      ...toEnableAutoPlacement ? [\n        autoPlacement(),\n      ]: [],\n      ...toEnableShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...toEnableFlip ? [\n        flip({\n          fallbackPlacements: ['right', 'left'],\n          fallbackStrategy: 'initialPlacement' // or `bestFit` (when no placement fits perfectly)\n        })\n      ]: [],\n      ...toShowArrow ? [\n        arrow({\n          element: arrowElement,\n          padding: TIP_EDGE_MARGIN,\n        })\n      ]: [],\n      size({\n        apply({width, height, reference, floating}) {\n        }\n      }),\n      hide()\n    ]\n  }\n\n  if (passedPlacement !== 'auto') {\n    computePositionConfig['placement'] = passedPlacement;\n  }\n\n  const fui = await computePosition(target, tooltipElement, computePositionConfig);\n  const { x, y, placement, middlewareData } = fui;\n\n  const { referenceHidden, escaped } = middlewareData.hide!;\n\n  if (referenceHidden && newlyShown) {\n    scrollElementIntoView(target);\n  }\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n  const arrowOffCenter = middlewareData.arrow!.centerOffset !== 0;\n\n  const visibility = ((\n    hideOnReferenceHidden && referenceHidden)\n    || (hideOnTooltipEscape && escaped)\n    || toHide) ? 'hidden' : 'visible';\n\n  tooltipElement.setAttribute('data-state', visibility);\n\n\n  Object.assign(tooltipElement.style, {\n    visibility,\n    left: `${x}px`,\n    top: `${y}px`\n  });\n\n  const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n  let staticSideTipSizeMultiplier: string | number = 0;\n  let top: string | number = 0;\n  let left: string | number = 0;\n  left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n  switch(staticSide) {\n    case 'top':\n      staticSideTipSizeMultiplier = 1/1.7;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'bottom':\n      staticSideTipSizeMultiplier = 1/2;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'left':\n      staticSideTipSizeMultiplier = 0.005;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n    case 'right':\n      staticSideTipSizeMultiplier = 1.2;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n  }\n\n  top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n  top = arrowY !== null ? `${arrowY}px` : \"\";\n  Object.assign(arrowElement.style, {\n    visibility: arrowOffCenter ? 'hidden' : 'visible',\n    left,\n    top,\n    right: \"\",\n    bottom: \"\",\n    [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n  });\n\n  if (newlyShown) {\n    console.log('setting state after newlyShown')\n  } else {\n    console.log('setting state on update')\n  }\n  setState({\n    isShown: visibility === 'visible',\n    fui\n  });\n\n  return fui;\n}\n\nexport default floatingUITooltip;\n","import { Instance, TooltipState } from './types';\n\nconst defaultProps = {\n  allowHTML: true,\n  content: '',\n  arrow: true,\n  scrollIntoView: false,\n  transitionDuration: [300, 250],\n  offset: [10, 0],\n  hideOnClick: true, // `true` for anywhere outside the tooltip to hide it, 'target' for only when the target is clicked\n  onClickOutside: (instance: Instance, event: MouseEvent) => {},\n  onShow: (instance: Instance) => {},\n  onHide: (instance: Instance) => {},\n  onStateChange: (oldState: TooltipState, newState: Partial<TooltipState>) => {},\n  onRemove: () => {},\n  placement: 'top',\n  resetPlacementOnUpdate: false,\n  hideOnTooltipEscape: true,\n  hideOnReferenceHidden: true,\n  showOnCreate: true,\n  maxWidth: 350,\n  updateDebounce: 100,\n  zIndex: 99999,\n  arrowSizeScale: 1,\n  updateOnEvents: 'resize scroll'\n}\n\nexport default defaultProps;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n","import createTooltipElement, { getChildren } from './tooltip-element';\nimport addCSS from './addCSS';\nimport { Props, TooltipState, Instance } from './types';\nimport floatingUITooltip from './floating-ui-tooltip';\nimport defaultProps from './defaultProps';\nimport debounce from './debounce';\nimport { doesElementHasTransition, onTransitionEnd } from './utils';\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: Ability to import js bundle without the css\n// TODO: Implement props.maxWidth\n// NOTE: Should the tooltip be appended to the body?\n// -- https://web.archive.org/web/20210827084020/https://atfzl.com/don-t-attach-tooltips-to-document-body\n\nconst appendTo = () => document.body;\n\n// TODO: continual scrolling delays the update, for as long as you can keep scrolling, fix that\n\n\nclass Tooltip {\n  readonly props: Props;\n  readonly reference: HTMLElement;\n  public tooltipElement!: HTMLDivElement;\n  private state: TooltipState = {\n    isShown: false,\n    isRemoved: false,\n    fui: undefined\n  }\n  private autoUpdateCleanup!: () => void;\n  private toHideTooltip: boolean = false;\n  private debouncedUpdate!: (arg: boolean | undefined) => void;\n  private transitionDuration: number = 0;\n\n  constructor(props: Props, target: HTMLElement) {\n    this.props = props;\n    this.reference = target;\n    window['tp'] = this;\n    addCSS();\n  }\n\n  private hookEventListeners() {\n    this.debouncedUpdate = debounce(\n      this.update.bind(this),\n      this.props.updateDebounce\n    );\n    this.autoUpdateCleanup = autoUpdate(\n      this.reference,\n      this.tooltipElement,\n      () => this.debouncedUpdate(undefined)\n    );\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.addEventListener(\n        <keyof WindowEventMap>event,\n        () => this.debouncedUpdate(undefined) as unknown as EventListenerOrEventListenerObject\n      );\n    });\n    window.addEventListener('click', this.clickHandler.bind(this));\n  }\n\n  private clickHandler = (event: MouseEvent) => {\n    if (!this.state.isShown) return;\n\n    // if click is outside of tooltip and reference\n    if (\n      !this.tooltipElement.contains(event.target as Node) &&\n      !this.reference.contains(event.target as Node)\n    ) {\n      if (this.props.onClickOutside) {\n        this.props.onClickOutside(this, event);\n      }\n    }\n\n    if (this.props.hideOnClick === 'target') {\n      if (event.target === this.reference) {\n        this.hide();\n      }\n    } else if (this.props.hideOnClick) {\n      this.hide();\n    }\n  }\n\n  private updateTransitionDuration(duration: number) {\n    this.transitionDuration = duration;\n    this.tooltipElement.style.transitionDuration = `${duration}ms`;\n  }\n\n  public async create() {\n    const toHide = !this.props.showOnCreate;\n    this.tooltipElement = createTooltipElement();\n    this.updateTransitionDuration(this.props.transitionDuration[0]);\n    const { content: contentBox } = getChildren(this.tooltipElement);\n    const { allowHTML, content } = this.props;\n    if (allowHTML) {\n      contentBox.innerHTML = content;\n    } else {\n      contentBox.innerText = `${content}`;\n    }\n\n    appendTo().appendChild(this.tooltipElement);\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      true,\n      this.setState.bind(this),\n    );\n    this.hookEventListeners();\n    /* console.log(this.props.onShow)\n    console.log(this.state.isShown) */\n  }\n\n  public getState(): TooltipState {\n    return this.state;\n  }\n\n  private setState(newState: Partial<TooltipState>) {\n    const visibilityChanged = typeof newState.isShown !== 'undefined' &&\n      newState.isShown !== this.state.isShown;\n\n    /* if(!visibilityChanged){\n      console.log('visibility not changed')\n    } else {\n      console.log('visibility changed')\n    } */\n\n    this.props.onStateChange(this.state, newState);\n\n    if (visibilityChanged && newState.isShown){\n      const debouncedOnShow = debounce(this.props.onShow, 0);\n      if(this.transitionDuration) {\n        onTransitionEnd(this.tooltipElement, () => {\n          debouncedOnShow(this);\n        });\n      } else {\n        debouncedOnShow(this);\n      }\n    }\n\n    this.state = {\n      ...this.state,\n      ...newState\n    }\n\n    if(visibilityChanged && !newState.isShown) {\n      this.props.onHide(this);\n    }\n  }\n\n  public async update(toHide?: boolean) {\n    toHide = toHide || this.toHideTooltip || false;\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      false,\n      this.setState.bind(this)\n    );\n  }\n  public async hide() {\n    // hide() when tooltip is already hidden should prevent event listeners\n    // from showing tooltip without before running show() manually\n    this.toHideTooltip = true;\n    await this.update(true);\n    this.updateTransitionDuration(this.props.transitionDuration[0]);\n  }\n\n  public async show() {\n    // this.props.onShow(this);\n    this.toHideTooltip = false;\n    await this.update(false);\n    this.updateTransitionDuration(this.props.transitionDuration[1]);\n  }\n\n  public remove() {\n    this.tooltipElement.remove();\n    this.state = {\n      isShown: false,\n      isRemoved: true,\n      fui: undefined\n    }\n    this.autoUpdateCleanup();\n    window.removeEventListener('click', this.clickHandler.bind(this));\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.removeEventListener(\n        <keyof WindowEventMap>event,\n        this.debouncedUpdate as unknown as EventListenerOrEventListenerObject\n      );\n    });\n    this.props.onRemove();\n  }\n}\n\nasync function createTooltip(\n  reference: HTMLElement,\n  props: Partial<Props>\n): Promise<Instance> {\n  const placement = props.placement || defaultProps.placement;\n  const transitionDuration = props.transitionDuration || defaultProps.transitionDuration;\n  const offset = props.offset || defaultProps.offset;\n  // offset needs to be size of the tooltip + backdrop gap (if applicable)\n\n  console.log(props.offset)\n  // NOTE: Interesting that the properties with undefined values still won't be replaced...\n  // -- keep this in mind for Lusift too\n\n\n  // remove properties with value of undefined\n  Object.keys(props).forEach(key => props[key] === undefined && delete props[key])\n\n  const allProps: Props = {\n    ...defaultProps,\n    ...props,\n    placement: <Props['placement']>placement,\n    transitionDuration: <Props['transitionDuration']>transitionDuration,\n    offset: <Props['offset']>offset,\n  };\n  const tooltipInstance = new Tooltip(allProps, reference);\n  await tooltipInstance.create();\n\n  const instance: Instance = {\n    props: tooltipInstance.props,\n    reference: tooltipInstance.reference,\n    tooltipElement: tooltipInstance.tooltipElement,\n    getState: tooltipInstance.getState.bind(tooltipInstance),\n    show: tooltipInstance.show.bind(tooltipInstance),\n    hide: tooltipInstance.hide.bind(tooltipInstance),\n    remove: tooltipInstance.remove.bind(tooltipInstance),\n    update: tooltipInstance.update.bind(tooltipInstance),\n  }\n\n  return instance;\n}\n\nexport default createTooltip;\n","import css from './css/style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n"],"names":["div","document","createElement","getChildren","tooltipElement","box","querySelector","content","arrow","undefined","updateTransitionEndListener","root","action","listener","method","forEach","event","TIP_SIDES_MAP","top","right","bottom","left","floatingUITooltip","tooltipProps","target","toHide","newlyShown","setState","toFlip","_b","_a","toShift","_c","passedPlacement","hideOnReferenceHidden","passedOffset","hideOnTooltipEscape","arrowSizeScale","resetPlacementOnUpdate","toShowArrow","_d","arrowElement","TIP_SIZE","toEnableAutoPlacement","toEnableFlip","toEnableShift","computePositionConfig","middleware","offset","mainAxis","crossAxis","autoPlacement","shift","padding","flip","fallbackPlacements","fallbackStrategy","element","size","apply","hide","computePosition","fui","_g","x","y","placement","middlewareData","_e","referenceHidden","escaped","scrollIntoView","behavior","block","inline","arrowX","arrowY","arrowOffCenter","centerOffset","visibility","setAttribute","Object","assign","style","staticSide","split","staticSideTipSizeMultiplier","console","log","isShown","defaultProps","allowHTML","transitionDuration","hideOnClick","onClickOutside","instance","onShow","onHide","onStateChange","oldState","newState","onRemove","showOnCreate","maxWidth","updateDebounce","zIndex","updateOnEvents","debounce","fn","ms","arg","clearTimeout","timeout","setTimeout","props","defaultStyle","this","isRemoved","_this","state","contains","reference","window","type","textContent","head","appendChild","Tooltip","debouncedUpdate","update","bind","autoUpdateCleanup","autoUpdate","addEventListener","clickHandler","duration","tooltipRoot","tooltipBox","tooltipContent","className","NODE_CLASSNAME_PREFIX","innerHTML","updateTransitionDuration","contentBox","innerText","body","hookEventListeners","visibilityChanged","debouncedOnShow_1","callback","e","onTransitionEnd","toHideTooltip","remove","removeEventListener","keys","key","allProps","tooltipInstance","create","getState","show"],"mappings":"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"}