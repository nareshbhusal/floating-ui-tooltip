{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/tooltip-element.ts","../src/setTooltipVisibility.ts","../src/floating-ui-tooltip.ts","../src/defaultProps.ts","../src/index.ts","../src/addCSS.ts","../src/debounce.ts"],"sourcesContent":["import { Visibility, TransitionState } from './types';\n\nexport function doesElementHasTransition(element: HTMLElement): boolean {\n    function getCSSPropertyValue(element: HTMLElement, property: string): string {\n        // not working with firefox, pulling property `transition`\n        return window.getComputedStyle(element).getPropertyValue(property);\n    }\n    const transitionDuration = getCSSPropertyValue(element, \"transition-duration\");\n    return !(transitionDuration === \"0s\" || transitionDuration === \"0ms\");\n}\n\nexport function updateTransitionEndListener(\n  root: HTMLDivElement,\n  action: 'add' | 'remove',\n  listener: (event: TransitionEvent) => void\n): void {\n  const method = `${action}EventListener` as\n  | 'addEventListener'\n  | 'removeEventListener';\n\n  [\n    'transitionend',\n    'webkitTransitionEnd',\n    'oTransitionEnd'\n  ].forEach((event) => {\n    root[method](event, listener as EventListener);\n  });\n}\n\nexport function setTransitionState(element: HTMLDivElement, state: TransitionState) {\n  element.setAttribute('data-transition-state', state);\n  console.log('>> new transition state: '+state)\n}\n\nexport function getTransitionState(element: HTMLDivElement): TransitionState {\n  return <TransitionState>element.getAttribute('data-transition-state');\n}\n\nexport function setElementVisibility(tooltipElement: HTMLDivElement, newVisibilityState: Visibility) {\n\n  tooltipElement.setAttribute('data-state', newVisibilityState);\n  Object.assign(tooltipElement.style, {\n    visibility: newVisibilityState,\n  });\n}\n\nexport function onTransitionEnd(element: HTMLDivElement, callback: Function) {\n\n  function listener(e) {\n    if(e.target === element) {\n      updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n      try {\n        callback();\n      } catch (err) {\n        console.error(err);\n        element['_instance'].props.onHide();\n      }\n    }\n  }\n  updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n  updateTransitionEndListener(<HTMLDivElement>element, 'add', listener);\n}\n\nexport function scrollElementIntoView(element: HTMLElement) {\n  element.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  });\n}\n","import { setTransitionState, setElementVisibility } from './utils';\n\nexport const NODE_CLASSNAME_PREFIX = 'floating-ui-tooltip';\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nconst createTooltipElement = (instanceEnv): HTMLDivElement => {\n\n  const tooltipRoot = div();\n  const tooltipBox = div();\n  const tooltipContent = div();\n  const arrowElement = div();\n\n  tooltipRoot.className = `${NODE_CLASSNAME_PREFIX}-root`;\n  tooltipBox.className = `${NODE_CLASSNAME_PREFIX}-box`;\n  tooltipContent.className = `${NODE_CLASSNAME_PREFIX}-content`;\n  arrowElement.className = `${NODE_CLASSNAME_PREFIX}-arrow`;\n\n  tooltipBox.appendChild(tooltipContent);\n  tooltipBox.appendChild(arrowElement);\n  tooltipRoot.appendChild(tooltipBox);\n\n  Object.assign(tooltipContent.style, {\n    maxWidth: `${instanceEnv.props.maxWidth}px`\n  })\n  tooltipContent.innerHTML = `\n    <div id=\"tooltip-container\">\n    <h3>Default tooltip</h3>\n    </div>\n  `;\n\n  tooltipBox.setAttribute('role', 'tooltip');\n  setElementVisibility(tooltipRoot, 'hidden');\n  setTransitionState(tooltipRoot, 'hidden');\n\n  Object.assign(tooltipRoot.style, {\n    zIndex: instanceEnv.props.zIndex,\n    visibility: 'hidden',\n    left: `0px`,\n    top: `0px`\n  });\n  tooltipRoot['_instance'] = instanceEnv;\n  return tooltipRoot;\n}\n\n\nexport interface TooltipElementChildren {\n  box: HTMLDivElement;\n  content: HTMLDivElement;\n  arrow: HTMLDivElement;\n}\n\nexport function getChildren(tooltipElement: Element): TooltipElementChildren {\n  return {\n    box: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-box`)!,\n    content: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-content`)!,\n    arrow: <HTMLDivElement>tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-arrow`) || undefined\n  };\n}\n\nexport default createTooltipElement;\n","import { onTransitionEnd, getTransitionState, setTransitionState, setElementVisibility } from './utils';\nimport { Visibility, TransitionState } from './types';\n\nfunction setTooltipVisibilityState(tooltipElement: HTMLDivElement, visibility: Visibility) {\n  const instance = tooltipElement['_instance'];\n  instance.setState({\n    isShown: visibility === 'visible'\n  });\n}\n\n// TODO: Any way to preserve the latest caught method call and to plug it at the end in onTransitionEnd callback?\n// -- [IMPORTANT]\n\nexport default function setTooltipVisibility(tooltipElement: HTMLDivElement, newVisibilityState: VisibilityState) {\n  const instance = tooltipElement['_instance'];\n  const currentTransitionState: TransitionState = getTransitionState(tooltipElement);\n\n  console.log('``````````')\n  console.log('\\n')\n  console.log(newVisibilityState, currentTransitionState);\n\n  if (newVisibilityState === 'visible') {\n    if (currentTransitionState === 'shown' || currentTransitionState === 'showing') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'hidden') {\n      console.log('showing')\n      setTransitionState(tooltipElement, 'showing');\n      // proceed to show\n\n    } else if (currentTransitionState === 'hiding') {\n      console.log(`cancelling ${currentTransitionState}`)\n      return;\n    }\n  } else {\n    if (currentTransitionState === 'hidden' || currentTransitionState === 'hiding') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'shown') {\n      setTransitionState(tooltipElement, 'hiding');\n      instance.props.onHide(instance);\n      // proceed to hide\n\n    } else if (currentTransitionState === 'showing') {\n      console.log(`cancelling ${currentTransitionState}`)\n      return;\n    }\n  }\n  const newTransitionState = newVisibilityState === 'visible' ? 'shown' : 'hidden';\n\n  if (instance.transitionDuration !== 0) {\n    onTransitionEnd(tooltipElement, () => {\n      setTooltipVisibilityState(tooltipElement, newVisibilityState);\n      setTransitionState(tooltipElement, newTransitionState);\n\n      newVisibilityState === 'visible' && instance.props.onShow(instance);\n    });\n\n    setElementVisibility(tooltipElement, newVisibilityState);\n  } else {\n    setElementVisibility(tooltipElement, newVisibilityState);\n    setTransitionState(tooltipElement, newTransitionState);\n    newVisibilityState === 'visible' && instance.props.onShow(instance);\n  }\n  // for hiding: run onHide hook before dom change\n  // for showing: make dom change before running onShow\n}\n","import {\n  computePosition,\n  size,\n  flip,\n  shift,\n  offset,\n  arrow,\n  autoPlacement,\n  hide,\n} from '@floating-ui/dom';\nimport { getChildren } from './tooltip-element';\nimport { Props, TooltipState, Visibility } from './types';\nimport { scrollElementIntoView } from './utils';\nimport setTooltipVisibility from './setTooltipVisibility';\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 2;\nconst DEFAULT_TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * DEFAULT_TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\nconst floatingUITooltip = async (\n  tooltipProps: Props,\n  tooltipElement: HTMLElement,\n  target: HTMLElement,\n  toHide: boolean,\n  newlyShown: boolean,\n  setState: (state: Partial<TooltipState>)=> void\n) => {\n const { toFlip=false, toShift=true } = {};\n\n  const {\n    placement: passedPlacement,\n    hideOnReferenceHidden,\n    offset: passedOffset,\n    hideOnTooltipEscape,\n    arrowSizeScale,\n    resetPlacementOnUpdate,\n    arrow: toShowArrow,\n    scrollIntoView,\n    showOnCreate\n  } = tooltipProps;\n\n  const { box, content, arrow: arrowElement } = getChildren(tooltipElement);\n  const TIP_SIZE = arrowSizeScale * DEFAULT_TIP_SIZE\n\n  if(!target) return;\n\n  const toEnableAutoPlacement = passedPlacement === 'auto' && (newlyShown || resetPlacementOnUpdate);\n  const toEnableFlip = (passedPlacement !== 'auto' && toFlip);\n  const toEnableShift = toShift && newlyShown;\n\n  const computePositionConfig = {\n    middleware: [\n      offset({\n        mainAxis: passedOffset[0],\n        crossAxis: passedOffset[1]\n      }),\n      ...toEnableAutoPlacement ? [\n        autoPlacement(),\n      ]: [],\n      ...toEnableShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...toEnableFlip ? [\n        flip({\n          fallbackPlacements: ['right', 'left'],\n          fallbackStrategy: 'initialPlacement' // or `bestFit` (when no placement fits perfectly)\n        })\n      ]: [],\n      ...toShowArrow ? [\n        arrow({\n          element: arrowElement,\n          padding: TIP_EDGE_MARGIN,\n        })\n      ]: [],\n      size({\n        apply({width, height, reference, floating}) {\n        }\n      }),\n      hide()\n    ]\n  }\n\n  if (passedPlacement !== 'auto') {\n    computePositionConfig['placement'] = passedPlacement;\n  }\n\n  const fui = await computePosition(target, tooltipElement, computePositionConfig);\n  const { x, y, placement, middlewareData } = fui;\n\n  const { referenceHidden, escaped } = middlewareData.hide!;\n\n  if (referenceHidden && newlyShown) {\n    scrollElementIntoView(target);\n  }\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n  const arrowOffCenter = middlewareData.arrow!.centerOffset !== 0;\n\n  let visibility: Visibility = ((\n    hideOnReferenceHidden && referenceHidden)\n    || (hideOnTooltipEscape && escaped)\n    || toHide) ? 'hidden' : 'visible' as const;\n\n  if (visibility === 'visible' && newlyShown && !showOnCreate){\n    visibility = 'hidden' as const;\n  }\n  /* console.log(hideOnReferenceHidden && referenceHidden, hideOnTooltipEscape && escaped, toHide)\n  console.log(visibility); */\n\n  setTooltipVisibility(<HTMLDivElement>tooltipElement, visibility);\n\n  Object.assign(tooltipElement.style, {\n    left: `${x}px`,\n    top: `${y}px`\n  });\n\n  const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n  let staticSideTipSizeMultiplier: string | number = 0;\n  let top: string | number = 0;\n  let left: string | number = 0;\n  left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n  switch(staticSide) {\n    case 'top':\n      staticSideTipSizeMultiplier = 1/1.7;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'bottom':\n      staticSideTipSizeMultiplier = 1/2;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'left':\n      staticSideTipSizeMultiplier = 0.005;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n    case 'right':\n      staticSideTipSizeMultiplier = 1.2;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n  }\n\n  top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n  top = arrowY !== null ? `${arrowY}px` : \"\";\n  Object.assign(arrowElement.style, {\n    visibility: arrowOffCenter ? 'hidden' : 'visible',\n    left,\n    top,\n    right: \"\",\n    bottom: \"\",\n    [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n  });\n\n  setState({\n    fui\n  });\n\n  return fui;\n}\n\nexport default floatingUITooltip;\n","import { Instance, TooltipState } from './types';\n\nconst defaultProps = {\n  allowHTML: true,\n  content: '',\n  arrow: true,\n  scrollIntoView: false,\n  transitionDuration: [300, 250],\n  offset: [10, 0],\n  hideOnClick: true, // `true` for anywhere outside the tooltip to hide it, 'target' for only when the target is clicked\n  onClickOutside: (instance: Instance, event: MouseEvent) => {},\n  onShow: (instance: Instance) => {},\n  onHide: (instance: Instance) => {},\n  onStateChange: (oldState: TooltipState, newState: Partial<TooltipState>) => {},\n  onRemove: () => {},\n  placement: 'top',\n  resetPlacementOnUpdate: false,\n  hideOnTooltipEscape: true,\n  hideOnReferenceHidden: true,\n  showOnCreate: true,\n  maxWidth: 350,\n  updateDebounce: 100,\n  zIndex: 99999,\n  arrowSizeScale: 1,\n  updateOnEvents: 'resize scroll'\n}\n\nexport default defaultProps;\n","import createTooltipElement, { getChildren } from './tooltip-element';\nimport addCSS from './addCSS';\nimport { Props, TooltipState, Instance } from './types';\nimport floatingUITooltip from './floating-ui-tooltip';\nimport defaultProps from './defaultProps';\nimport debounce from './debounce';\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: Ability to import js bundle without the css\n// NOTE: Should the tooltip be appended to the body?\n// -- https://web.archive.org/web/20210827084020/https://atfzl.com/don-t-attach-tooltips-to-document-body\n\nconst appendTo = () => document.body;\n\nclass Tooltip {\n  readonly props: Props;\n  readonly reference: HTMLElement;\n  public tooltipElement!: HTMLDivElement;\n  private state: TooltipState = {\n    isShown: false,\n    isRemoved: false,\n    fui: undefined\n  }\n  private updateListenerCleanup: () => void = () => {};\n  private toHideTooltip: boolean = false;\n  private debouncedUpdate!: (arg: boolean | undefined) => void;\n  private transitionDuration: number = 0;\n\n  constructor(props: Props, target: HTMLElement) {\n    this.props = props;\n    this.reference = target;\n    // window['tp'] = this;\n    addCSS();\n    this.toHideTooltip = !this.props.showOnCreate;\n  }\n\n  private hookEventListeners() {\n    this.debouncedUpdate = debounce(\n      this.update.bind(this),\n      this.props.updateDebounce\n    );\n    const autoUpdateCleanup = autoUpdate(\n      this.reference,\n      this.tooltipElement,\n      () => this.debouncedUpdate(undefined),\n    );\n\n    const debouncedUpdateHandler = () =>\n      this.debouncedUpdate(undefined) as unknown as EventListenerOrEventListenerObject;\n\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.addEventListener(\n        <keyof WindowEventMap>event,\n        debouncedUpdateHandler\n      );\n    });\n    window.addEventListener('click', this.clickHandler.bind(this));\n\n    // prepare event listeners' cleanup method\n    this.updateListenerCleanup = () => {\n      autoUpdateCleanup();\n      window.removeEventListener('click', this.clickHandler.bind(this));\n\n      this.props.updateOnEvents.split(' ').forEach(event => {\n        window.removeEventListener(\n          <keyof WindowEventMap>event,\n          debouncedUpdateHandler\n        );\n      });\n    }\n  }\n\n  private clickHandler = (event: MouseEvent) => {\n    if (!this.state.isShown) return;\n\n    // if click is outside of tooltip and reference\n    if (\n      !this.tooltipElement.contains(event.target as Node) &&\n      !this.reference.contains(event.target as Node)\n    ) {\n      if (this.props.onClickOutside) {\n        this.props.onClickOutside(this, event);\n      }\n    }\n\n    if (this.props.hideOnClick === 'target') {\n      if (event.target === this.reference) {\n        this.hide();\n      }\n    } else if (this.props.hideOnClick) {\n      this.hide();\n    }\n  }\n\n  private updateTransitionDuration(duration: number) {\n    this.transitionDuration = duration;\n    this.tooltipElement.style.transitionDuration = `${duration}ms`;\n  }\n\n  public async create() {\n    const toHide = !this.props.showOnCreate;\n    this.tooltipElement = createTooltipElement(this);\n    this.updateTransitionDuration(\n      this.props.transitionDuration[toHide ? 0 : 1]\n    );\n    const { content: contentBox } = getChildren(this.tooltipElement);\n    const { allowHTML, content } = this.props;\n    if (allowHTML) {\n      contentBox.innerHTML = content;\n    } else {\n      contentBox.innerText = `${content}`;\n    }\n\n    appendTo().appendChild(this.tooltipElement);\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      true,\n      this.setState.bind(this),\n    );\n    this.hookEventListeners();\n  }\n\n  public getState(): TooltipState {\n    return this.state;\n  }\n\n  private setState(newState: Partial<TooltipState>) {\n    const visibilityChanged = typeof newState.isShown !== 'undefined' &&\n      newState.isShown !== this.state.isShown;\n\n    if (visibilityChanged) {\n      this.updateTransitionDuration(\n        this.props.transitionDuration[newState.isShown ? 1 : 0]\n      );\n    }\n\n    this.props.onStateChange(this.state, newState);\n\n    this.state = {\n      ...this.state,\n      ...newState\n    }\n  }\n\n  public async update(toHide?: boolean) {\n    toHide = toHide || this.toHideTooltip || false;\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      false,\n      this.setState.bind(this)\n    );\n  }\n\n  public async hide() {\n    // hide() when tooltip is already hidden should prevent event listeners\n    // from showing tooltip without before running show() manually\n    this.toHideTooltip = true;\n    await this.update(true);\n  }\n\n  public async show() {\n    this.toHideTooltip = false;\n    await this.update(false);\n  }\n\n  public remove() {\n    this.tooltipElement.remove();\n    this.state = {\n      isShown: false,\n      isRemoved: true,\n      fui: undefined\n    }\n    this.updateListenerCleanup();\n    console.log('removed all event listeners and observers');\n    this.props.onRemove();\n  }\n}\n\nasync function createTooltip(\n  reference: HTMLElement,\n  props: Partial<Props>\n): Promise<Instance> {\n  const placement = props.placement || defaultProps.placement;\n  const transitionDuration = props.transitionDuration || defaultProps.transitionDuration;\n  const offset = props.offset || defaultProps.offset;\n\n  // NOTE: Interesting that the properties with undefined values still won't be replaced...\n  // -- Relevant to Lusift?\n\n  // remove properties with value of undefined\n  Object.keys(props).forEach(key => props[key] === undefined && delete props[key])\n\n  const allProps: Props = {\n    ...defaultProps,\n    ...props,\n    placement: <Props['placement']>placement,\n    transitionDuration: <Props['transitionDuration']>transitionDuration,\n    offset: <Props['offset']>offset,\n  };\n  const tooltipInstance = new Tooltip(allProps, reference);\n  await tooltipInstance.create();\n\n  const instance: Instance = {\n    props: tooltipInstance.props,\n    reference: tooltipInstance.reference,\n    tooltipElement: tooltipInstance.tooltipElement,\n    getState: tooltipInstance.getState.bind(tooltipInstance),\n    show: tooltipInstance.show.bind(tooltipInstance),\n    hide: tooltipInstance.hide.bind(tooltipInstance),\n    remove: tooltipInstance.remove.bind(tooltipInstance),\n    update: tooltipInstance.update.bind(tooltipInstance),\n  }\n\n  return instance;\n}\n\nexport default createTooltip;\n","import css from './css/style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n"],"names":["updateTransitionEndListener","root","action","listener","method","forEach","event","setTransitionState","element","state","setAttribute","console","log","setElementVisibility","tooltipElement","newVisibilityState","Object","assign","style","visibility","div","document","createElement","getChildren","box","querySelector","content","arrow","undefined","setTooltipVisibility","instance","currentTransitionState","getAttribute","props","onHide","newTransitionState","transitionDuration","callback","e","target","err","error","onTransitionEnd","setState","isShown","setTooltipVisibilityState","onShow","TIP_SIDES_MAP","top","right","bottom","left","floatingUITooltip","tooltipProps","toHide","newlyShown","toFlip","_b","_a","toShift","_c","passedPlacement","hideOnReferenceHidden","passedOffset","hideOnTooltipEscape","arrowSizeScale","resetPlacementOnUpdate","toShowArrow","showOnCreate","_d","arrowElement","TIP_SIZE","toEnableAutoPlacement","toEnableFlip","toEnableShift","computePositionConfig","middleware","offset","mainAxis","crossAxis","autoPlacement","shift","padding","flip","fallbackPlacements","fallbackStrategy","size","apply","hide","computePosition","fui","_g","x","y","placement","middlewareData","_e","referenceHidden","escaped","scrollIntoView","behavior","block","inline","arrowX","arrowY","arrowOffCenter","centerOffset","staticSide","split","staticSideTipSizeMultiplier","defaultProps","allowHTML","hideOnClick","onClickOutside","onStateChange","oldState","newState","onRemove","maxWidth","updateDebounce","zIndex","updateOnEvents","defaultStyle","this","isRemoved","_this","contains","reference","type","textContent","head","appendChild","toHideTooltip","Tooltip","fn","ms","timeout","debouncedUpdate","update","bind","arg","clearTimeout","setTimeout","autoUpdateCleanup","autoUpdate","debouncedUpdateHandler","window","addEventListener","clickHandler","updateListenerCleanup","removeEventListener","duration","instanceEnv","tooltipRoot","tooltipBox","tooltipContent","className","NODE_CLASSNAME_PREFIX","innerHTML","updateTransitionDuration","contentBox","innerText","body","hookEventListeners","remove","keys","key","allProps","tooltipInstance","create","getState","show"],"mappings":"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"}