{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/tooltip-element.ts","../src/setTooltipVisibility.ts","../src/floating-ui-tooltip.ts","../src/defaultProps.ts","../src/index.ts","../src/addCSS.ts","../src/debounce.ts"],"sourcesContent":["import { Visibility, TransitionState } from './types';\n\nexport function doesElementHasTransition(element: HTMLElement): boolean {\n    function getCSSPropertyValue(element: HTMLElement, property: string): string {\n        // not working with firefox, pulling property `transition`\n        return window.getComputedStyle(element).getPropertyValue(property);\n    }\n    const transitionDuration = getCSSPropertyValue(element, \"transition-duration\");\n    return !(transitionDuration === \"0s\" || transitionDuration === \"0ms\");\n}\n\nexport function updateTransitionEndListener(\n  root: HTMLDivElement,\n  action: 'add' | 'remove',\n  listener: (event: TransitionEvent) => void\n): void {\n  const method = `${action}EventListener` as\n  | 'addEventListener'\n  | 'removeEventListener';\n\n  [\n    'transitionend',\n    'webkitTransitionEnd',\n    'oTransitionEnd'\n  ].forEach((event) => {\n    root[method](event, listener as EventListener);\n  });\n}\n\nexport function setTransitionState(element: HTMLDivElement, state: TransitionState) {\n  element.setAttribute('data-transition-state', state);\n  console.log('>> new transition state: '+state)\n}\n\nexport function getTransitionState(element: HTMLDivElement): TransitionState {\n  return <TransitionState>element.getAttribute('data-transition-state');\n}\n\nexport function setElementVisibility(tooltipElement: HTMLDivElement, newVisibilityState: Visibility) {\n\n  tooltipElement.setAttribute('data-state', newVisibilityState);\n  Object.assign(tooltipElement.style, {\n    visibility: newVisibilityState,\n  });\n}\n\nexport function onTransitionEnd(element: HTMLDivElement, callback: Function) {\n\n  function listener(e) {\n    if(e.target === element) {\n      updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n      try {\n        callback();\n      } catch (err) {\n        console.error(err);\n        element['_instance'].props.onHide();\n      }\n    }\n  }\n  updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n  updateTransitionEndListener(<HTMLDivElement>element, 'add', listener);\n}\n\nexport function scrollElementIntoView(element: HTMLElement) {\n  element.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  });\n}\n","import { setTransitionState, setElementVisibility } from './utils';\n\nexport const NODE_CLASSNAME_PREFIX = 'floating-ui-tooltip';\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nconst createTooltipElement = (instanceEnv): HTMLDivElement => {\n\n  const tooltipRoot = div();\n  const tooltipBox = div();\n  const tooltipContent = div();\n  const arrowElement = div();\n\n  tooltipRoot.className = `${NODE_CLASSNAME_PREFIX}-root`;\n  tooltipBox.className = `${NODE_CLASSNAME_PREFIX}-box`;\n  tooltipContent.className = `${NODE_CLASSNAME_PREFIX}-content`;\n  arrowElement.className = `${NODE_CLASSNAME_PREFIX}-arrow`;\n\n  tooltipBox.appendChild(tooltipContent);\n  tooltipBox.appendChild(arrowElement);\n  tooltipRoot.appendChild(tooltipBox);\n\n  Object.assign(tooltipContent.style, {\n    maxWidth: `${instanceEnv.props.maxWidth}px`\n  })\n  tooltipContent.innerHTML = `\n    <div id=\"tooltip-container\">\n    <h3>Default tooltip</h3>\n    </div>\n  `;\n\n  tooltipBox.setAttribute('role', 'tooltip');\n  setElementVisibility(tooltipRoot, 'hidden');\n  setTransitionState(tooltipRoot, 'hidden');\n\n  Object.assign(tooltipRoot.style, {\n    zIndex: instanceEnv.props.zIndex,\n    visibility: 'hidden',\n    left: `0px`,\n    top: `0px`\n  });\n  tooltipRoot['_instance'] = instanceEnv;\n  return tooltipRoot;\n}\n\n\nexport interface TooltipElementChildren {\n  box: HTMLDivElement;\n  content: HTMLDivElement;\n  arrow: HTMLDivElement;\n}\n\nexport function getChildren(tooltipElement: Element): TooltipElementChildren {\n  return {\n    box: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-box`)!,\n    content: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-content`)!,\n    arrow: <HTMLDivElement>tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-arrow`) || undefined\n  };\n}\n\nexport default createTooltipElement;\n","import { onTransitionEnd, getTransitionState, setTransitionState, setElementVisibility } from './utils';\nimport { Visibility, TransitionState } from './types';\n\nfunction setTooltipVisibilityState(tooltipElement: HTMLDivElement, visibility: Visibility) {\n  const instance = tooltipElement['_instance'];\n  instance.setState({\n    isShown: visibility === 'visible'\n  });\n}\n\n// TODO: Any way to preserve the latest caught method call and to plug it at the end in onTransitionEnd callback?\n// -- [IMPORTANT]\nlet LAST_VISIBILITY_STATE: VisibilityState | '' = '';\n// TODO: Maybe just try running this as a debounce method\n// -- debounce method runs the last call right?\n\nexport default function setTooltipVisibility(tooltipElement: HTMLDivElement, newVisibilityState: VisibilityState) {\n  const instance = tooltipElement['_instance'];\n  const currentTransitionState: TransitionState = getTransitionState(tooltipElement);\n\n  console.log('``````````')\n  console.log('\\n')\n  console.log(newVisibilityState, currentTransitionState);\n\n  if (newVisibilityState === 'visible') {\n    if (currentTransitionState === 'shown' || currentTransitionState === 'showing') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'hidden') {\n      console.log('showing')\n      LAST_VISIBILITY_STATE = '';\n      setTransitionState(tooltipElement, 'showing');\n      // proceed to show\n\n    } else if (currentTransitionState === 'hiding') {\n      console.log(`cancelling ${currentTransitionState}`)\n      LAST_VISIBILITY_STATE = newVisibilityState;\n      // NOTE: where should this be again?^\n      return;\n    }\n  } else {\n    if (currentTransitionState === 'hidden' || currentTransitionState === 'hiding') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'shown') {\n      LAST_VISIBILITY_STATE = '';\n      setTransitionState(tooltipElement, 'hiding');\n      instance.props.onHide(instance);\n      // proceed to hide\n\n    } else if (currentTransitionState === 'showing') {\n      console.log(`cancelling ${currentTransitionState}`)\n      LAST_VISIBILITY_STATE = newVisibilityState;\n      return;\n    }\n  }\n  const newTransitionState = newVisibilityState === 'visible' ? 'shown' : 'hidden';\n\n  if (instance.transitionDuration !== 0) {\n    onTransitionEnd(tooltipElement, () => {\n      setTooltipVisibilityState(tooltipElement, newVisibilityState);\n      setTransitionState(tooltipElement, newTransitionState);\n\n      newVisibilityState === 'visible' && instance.props.onShow(instance);\n      /* if (LAST_VISIBILITY_STATE) {\n        console.log('LAST EVENT FIRED')\n        setTooltipVisibility(tooltipElement, LAST_VISIBILITY_STATE);\n      } */\n    });\n\n    setElementVisibility(tooltipElement, newVisibilityState);\n  } else {\n    setElementVisibility(tooltipElement, newVisibilityState);\n    setTransitionState(tooltipElement, newTransitionState);\n    newVisibilityState === 'visible' && instance.props.onShow(instance);\n  }\n  // for hiding: run onHide hook before dom change\n  // for showing: make dom change before running onShow\n}\n","import {\n  computePosition,\n  size,\n  flip,\n  shift,\n  offset,\n  arrow,\n  autoPlacement,\n  hide,\n} from '@floating-ui/dom';\nimport { getChildren } from './tooltip-element';\nimport { Props, TooltipState, Visibility, Placement, Position } from './types';\nimport { scrollElementIntoView } from './utils';\nimport setTooltipVisibility from './setTooltipVisibility';\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 2;\nconst DEFAULT_TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * DEFAULT_TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\n// TODO: but this shouldn't change if it isn't newlyShown right?\nconst getPosition = ({ passedPlacement, fui, newlyShown }): Position => {\n  const {\n    position,\n    orientation\n  } = passedPlacement;\n  if (!fui || !newlyShown) return position;\n  const { x, y } = fui;\n  // if x or y is less than 0, and orientation is auto: return auto\n  if (x < 0 || y < 0) {\n    if (orientation === 'auto') {\n      return 'auto';\n    }\n  }\n  return position;\n}\n\nconst computeTooltip = async ({ passedPlacement, passedOffset, resetPlacementOnUpdate, newlyShown, toShift, toShowArrow, arrowElement, tooltipElement, target }) => {\n\n  const position = getPosition({\n    passedPlacement,\n    fui: tooltipElement['_instance'].state.fui,\n    newlyShown\n  });\n  console.log(`fui is:`)\n  console.log(tooltipElement['_instance'].state.fui)\n  console.log(`position now should be ${position}`)\n\n  const toEnableAutoPlacement = position === 'auto' && (newlyShown || resetPlacementOnUpdate);\n  const toEnableShift = toShift && newlyShown;\n\n  const computePositionConfig = {\n    ...position !== 'auto' && {\n      placement: position,\n    },\n    middleware: [\n      offset({\n        mainAxis: passedOffset[0],\n        crossAxis: passedOffset[1]\n      }),\n      ...toEnableAutoPlacement ? [\n        autoPlacement(),\n      ]: [],\n      ...toEnableShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...toShowArrow ? [\n        arrow({\n          element: arrowElement,\n          padding: TIP_EDGE_MARGIN,\n        })\n      ]: [],\n      size({\n        apply({width, height, reference, floating}) {\n        }\n      }),\n      hide()\n    ]\n  }\n  return await computePosition(target, tooltipElement, computePositionConfig);\n}\n\nconst floatingUITooltip = async (\n  tooltipProps: Props,\n  tooltipElement: HTMLElement,\n  target: HTMLElement,\n  toHide: boolean,\n  newlyShown: boolean,\n  setState: (state: Partial<TooltipState>)=> void\n) => {\n const { toFlip=false, toShift=true } = {};\n\n  let {\n    placement: passedPlacement,\n    hideOnReferenceHidden,\n    offset: passedOffset,\n    hideOnTooltipEscape,\n    arrowSizeScale,\n    resetPlacementOnUpdate,\n    arrow: toShowArrow,\n    scrollIntoView,\n    showOnCreate\n  } = tooltipProps;\n\n  const { arrow: arrowElement } = getChildren(tooltipElement);\n\n  if(!target) return;\n\n  let fui = await computeTooltip({ passedPlacement, passedOffset, resetPlacementOnUpdate, toShift, toShowArrow, arrowElement, tooltipElement, target, newlyShown });\n\n  if (newlyShown) {\n    console.log('---')\n    console.log('refiring computePosition because it\\'s newlyshown')\n    fui = await computeTooltip({ passedPlacement, passedOffset, resetPlacementOnUpdate, toShift, toShowArrow, arrowElement, tooltipElement, target, newlyShown });\n    console.log(`fui is:`)\n    console.log(tooltipElement['_instance'].state.fui)\n    console.log('---')\n  }\n\n  const { x, y, placement, middlewareData } = fui;\n\n  const { referenceHidden, escaped } = middlewareData.hide!;\n\n  if (referenceHidden && newlyShown && scrollIntoView) {\n    scrollElementIntoView(target);\n  }\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n  const arrowOffCenter = middlewareData.arrow!.centerOffset !== 0;\n\n  let visibility: Visibility = ((\n    hideOnReferenceHidden && referenceHidden)\n    || (hideOnTooltipEscape && escaped)\n    || toHide) ? 'hidden' : 'visible' as const;\n\n  console.log(`to change visibility to: ${visibility}`)\n\n  if (visibility === 'visible' && newlyShown && !showOnCreate){\n    visibility = 'hidden' as const;\n  }\n  /* console.log(hideOnReferenceHidden && referenceHidden, hideOnTooltipEscape && escaped, toHide)\n  console.log(visibility); */\n\n  setTooltipVisibility(<HTMLDivElement>tooltipElement, visibility);\n\n  Object.assign(tooltipElement.style, {\n    left: `${x}px`,\n    top: `${y}px`\n  });\n\n  const TIP_SIZE = arrowSizeScale * DEFAULT_TIP_SIZE;\n\n  const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n  let staticSideTipSizeMultiplier: string | number = 0;\n  let top: string | number = 0;\n  let left: string | number = 0;\n  left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n  switch(staticSide) {\n    case 'top':\n      staticSideTipSizeMultiplier = 1/1.7;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'bottom':\n      staticSideTipSizeMultiplier = 1/2;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'left':\n      staticSideTipSizeMultiplier = 0.005;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n    case 'right':\n      staticSideTipSizeMultiplier = 1.2;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n  }\n\n  top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n  top = arrowY !== null ? `${arrowY}px` : \"\";\n  Object.assign(arrowElement.style, {\n    visibility: arrowOffCenter ? 'hidden' : 'visible',\n    left,\n    top,\n    right: \"\",\n    bottom: \"\",\n    [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n  });\n\n  setState({\n    fui\n  });\n\n  return fui;\n}\n\nexport default floatingUITooltip;\n","import { Instance, TooltipState } from './types';\n\nconst defaultProps = {\n  allowHTML: true,\n  content: '',\n  arrow: true,\n  scrollIntoView: false,\n  transitionDuration: [300, 250],\n  offset: [10, 0],\n  hideOnClick: true, // `true` for anywhere outside the tooltip to hide it, 'target' for only when the target is clicked\n  onClickOutside: (instance: Instance, event: MouseEvent) => {},\n  onShow: (instance: Instance) => {},\n  onHide: (instance: Instance) => {},\n  onStateChange: (oldState: TooltipState, newState: Partial<TooltipState>) => {},\n  onRemove: () => {},\n  onBeforeFirstRender: () => {},\n  placement: {\n    position: 'top',\n    orientation: 'fixed'\n  },\n  resetPlacementOnUpdate: false,\n  hideOnTooltipEscape: true,\n  hideOnReferenceHidden: true,\n  showOnCreate: true,\n  maxWidth: 350,\n  updateDebounce: 100,\n  zIndex: 99999,\n  arrowSizeScale: 1,\n  updateOnEvents: 'resize scroll'\n}\n\nexport default defaultProps;\n","import createTooltipElement, { getChildren } from './tooltip-element';\nimport addCSS from './addCSS';\nimport { Props, TooltipState, Instance } from './types';\nimport floatingUITooltip from './floating-ui-tooltip';\nimport defaultProps from './defaultProps';\nimport debounce from './debounce';\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: Ability to import js bundle without the css\n// NOTE: Should the tooltip be appended to the body?\n// -- https://web.archive.org/web/20210827084020/https://atfzl.com/don-t-attach-tooltips-to-document-body\n\nconst appendTo = () => document.body;\n\nclass Tooltip {\n  readonly props: Props;\n  readonly reference: HTMLElement;\n  public tooltipElement!: HTMLDivElement;\n  private state: TooltipState = {\n    isShown: false,\n    isRemoved: false,\n    fui: undefined\n  }\n  private updateListenerCleanup: () => void = () => {};\n  private toHideTooltip: boolean = false;\n  private debouncedUpdate!: (arg: boolean | undefined) => void;\n  private transitionDuration: number = 0;\n\n  constructor(props: Props, target: HTMLElement) {\n    this.props = props;\n    // this.props.updateDebounce = 0; // test\n    this.reference = target;\n    // window['tp'] = this;\n    addCSS();\n    this.toHideTooltip = !this.props.showOnCreate;\n  }\n\n  private hookEventListeners() {\n    this.debouncedUpdate = debounce(\n      this.update.bind(this),\n      this.props.updateDebounce\n    );\n    const autoUpdateCleanup = autoUpdate(\n      this.reference,\n      this.tooltipElement,\n      () => this.debouncedUpdate(undefined),\n    );\n\n    const debouncedUpdateHandler = () =>\n      this.debouncedUpdate(undefined) as unknown as EventListenerOrEventListenerObject;\n\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.addEventListener(\n        <keyof WindowEventMap>event,\n        debouncedUpdateHandler\n      );\n    });\n    window.addEventListener('click', this.clickHandler.bind(this));\n\n    // prepare event listeners' cleanup method\n    this.updateListenerCleanup = () => {\n      autoUpdateCleanup();\n      window.removeEventListener('click', this.clickHandler.bind(this));\n\n      this.props.updateOnEvents.split(' ').forEach(event => {\n        window.removeEventListener(\n          <keyof WindowEventMap>event,\n          debouncedUpdateHandler\n        );\n      });\n    }\n  }\n\n  private clickHandler = (event: MouseEvent) => {\n    if (!this.state.isShown) return;\n\n    // if click is outside of tooltip and reference\n    if (\n      !this.tooltipElement.contains(event.target as Node) &&\n      !this.reference.contains(event.target as Node)\n    ) {\n      if (this.props.onClickOutside) {\n        this.props.onClickOutside(this, event);\n      }\n    }\n\n    if (this.props.hideOnClick === 'target') {\n      if (event.target === this.reference) {\n        this.hide();\n      }\n    } else if (this.props.hideOnClick) {\n      this.hide();\n    }\n  }\n\n  private updateTransitionDuration(duration: number) {\n    this.transitionDuration = duration;\n    this.tooltipElement.style.transitionDuration = `${duration}ms`;\n  }\n\n  // TODO: we'll need to decouple creation of dom element and first run of fui\n  // for the Lusift consumer\n  public async create() {\n    const toHide = !this.props.showOnCreate;\n    this.tooltipElement = createTooltipElement(this);\n    this.updateTransitionDuration(\n      this.props.transitionDuration[toHide ? 0 : 1]\n    );\n    const { content: contentBox } = getChildren(this.tooltipElement);\n    const { allowHTML, content } = this.props;\n    if (allowHTML) {\n      contentBox.innerHTML = content;\n    } else {\n      contentBox.innerText = `${content}`;\n    }\n\n    appendTo().appendChild(this.tooltipElement);\n\n    const initFloatingUI = async () => {\n      await floatingUITooltip(\n        this.props,\n        this.tooltipElement,\n        this.reference,\n        toHide,\n        true,\n        this.setState.bind(this),\n      );\n      this.hookEventListeners();\n    }\n    // TODO: onBeforeFirstRender()\n    this.props.onBeforeFirstRender();\n    await initFloatingUI();\n  }\n\n  public getState(): TooltipState {\n    return this.state;\n  }\n\n  private setState(newState: Partial<TooltipState>) {\n    const visibilityChanged = typeof newState.isShown !== 'undefined' &&\n      newState.isShown !== this.state.isShown;\n\n    if (visibilityChanged) {\n      this.updateTransitionDuration(\n        this.props.transitionDuration[newState.isShown ? 1 : 0]\n      );\n    }\n\n    this.props.onStateChange(this.state, newState);\n\n    this.state = {\n      ...this.state,\n      ...newState\n    }\n  }\n\n  public async update(toHide?: boolean) {\n    toHide = toHide || this.toHideTooltip || false;\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      false,\n      this.setState.bind(this)\n    );\n  }\n\n  public async hide() {\n    // hide() when tooltip is already hidden should prevent event listeners\n    // from showing tooltip without before running show() manually\n    this.toHideTooltip = true;\n    await this.update(true);\n  }\n\n  public async show() {\n    this.toHideTooltip = false;\n    await this.update(false);\n  }\n\n  public remove() {\n    this.tooltipElement.remove();\n    this.state = {\n      isShown: false,\n      isRemoved: true,\n      fui: undefined\n    }\n    this.updateListenerCleanup();\n    console.log('removed all event listeners and observers');\n    this.props.onRemove();\n  }\n}\n\nasync function createTooltip(\n  reference: HTMLElement,\n  props: Partial<Props>\n): Promise<Instance> {\n  const placement = props.placement || defaultProps.placement;\n  const transitionDuration = props.transitionDuration || defaultProps.transitionDuration;\n  const offset = props.offset || defaultProps.offset;\n\n  // NOTE: Interesting that the properties with undefined values still won't be replaced...\n  // -- Relevant to Lusift?\n\n  // remove properties with value of undefined\n  Object.keys(props).forEach(key => props[key] === undefined && delete props[key])\n\n  const allProps: Props = {\n    ...defaultProps,\n    ...props,\n    placement: <Props['placement']>placement,\n    transitionDuration: <Props['transitionDuration']>transitionDuration,\n    offset: <Props['offset']>offset,\n  };\n  const tooltipInstance = new Tooltip(allProps, reference);\n  await tooltipInstance.create();\n\n  const instance: Instance = {\n    props: tooltipInstance.props,\n    reference: tooltipInstance.reference,\n    tooltipElement: tooltipInstance.tooltipElement,\n    getState: tooltipInstance.getState.bind(tooltipInstance),\n    show: tooltipInstance.show.bind(tooltipInstance),\n    hide: tooltipInstance.hide.bind(tooltipInstance),\n    remove: tooltipInstance.remove.bind(tooltipInstance),\n    update: tooltipInstance.update.bind(tooltipInstance),\n  }\n\n  return instance;\n}\n\nexport default createTooltip;\n","import css from './css/style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n"],"names":["updateTransitionEndListener","root","action","listener","method","forEach","event","setTransitionState","element","state","setAttribute","console","log","setElementVisibility","tooltipElement","newVisibilityState","Object","assign","style","visibility","div","document","createElement","getChildren","box","querySelector","content","arrow","undefined","setTooltipVisibility","instance","currentTransitionState","getAttribute","props","onHide","newTransitionState","transitionDuration","callback","e","target","err","error","onTransitionEnd","setState","isShown","setTooltipVisibilityState","onShow","TIP_SIDES_MAP","top","right","bottom","left","computeTooltip","_a","passedPlacement","passedOffset","resetPlacementOnUpdate","newlyShown","toShift","toShowArrow","arrowElement","position","fui","orientation","x","y","getPosition","toEnableAutoPlacement","toEnableShift","computePositionConfig","placement","middleware","offset","mainAxis","crossAxis","autoPlacement","shift","padding","size","apply","hide","computePosition","_b","floatingUITooltip","tooltipProps","toHide","_c","hideOnReferenceHidden","hideOnTooltipEscape","arrowSizeScale","scrollIntoView","showOnCreate","_f","middlewareData","_d","referenceHidden","escaped","behavior","block","inline","arrowX","arrowY","arrowOffCenter","centerOffset","TIP_SIZE","staticSide","split","staticSideTipSizeMultiplier","defaultProps","allowHTML","hideOnClick","onClickOutside","onStateChange","oldState","newState","onRemove","onBeforeFirstRender","maxWidth","updateDebounce","zIndex","updateOnEvents","defaultStyle","this","isRemoved","_this","contains","reference","type","textContent","head","appendChild","toHideTooltip","Tooltip","fn","ms","timeout","debouncedUpdate","update","bind","arg","clearTimeout","setTimeout","autoUpdateCleanup","autoUpdate","debouncedUpdateHandler","window","addEventListener","clickHandler","updateListenerCleanup","removeEventListener","duration","instanceEnv","tooltipRoot","tooltipBox","tooltipContent","className","NODE_CLASSNAME_PREFIX","innerHTML","updateTransitionDuration","contentBox","innerText","body","initFloatingUI","hookEventListeners","remove","keys","key","allProps","tooltipInstance","create","getState","show"],"mappings":"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"}