{"version":3,"file":"index.js","sources":["../node_modules/@floating-ui/core/dist/floating-ui.core.esm.js","../node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js","../src/index.ts","../src/addCSS.ts"],"sourcesContent":["function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\n\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getBasePlacement(placement)) ? 'x' : 'y';\n}\n\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\n\nfunction computeCoordsFromPlacement(_ref) {\n  let {\n    reference,\n    floating,\n    placement\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  let coords;\n\n  switch (getBasePlacement(placement)) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] = coords[mainAxis] - (reference[length] / 2 - floating[length] / 2);\n      break;\n\n    case 'end':\n      coords[mainAxis] = coords[mainAxis] + (reference[length] / 2 - floating[length] / 2);\n      break;\n  }\n\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (platform == null) {\n      console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n    }\n\n    if (middleware.filter(_ref => {\n      let {\n        name\n      } = _ref;\n      return name === 'autoPlacement' || name === 'flip';\n    }).length > 1) {\n      throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement`', 'middleware detected. This will lead to an infinite loop. Ensure only', 'one of either has been passed to the `middleware` array.'].join(' '));\n    }\n  }\n\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement({ ...rects,\n    placement\n  });\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let _debug_loop_count_ = 0;\n\n  for (let i = 0; i < middleware.length; i++) {\n    if (process.env.NODE_ENV !== \"production\") {\n      _debug_loop_count_++;\n\n      if (_debug_loop_count_ > 100) {\n        throw new Error(['Floating UI: The middleware lifecycle appears to be', 'running in an infinite loop. This is usually caused by a `reset`', 'continually being returned without a break condition.'].join(' '));\n      }\n    }\n\n    const {\n      name,\n      fn\n    } = middleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = { ...middlewareData,\n      [name]: data != null ? data : {}\n    };\n\n    if (reset) {\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement({ ...rects,\n          placement: statefulPlacement\n        }));\n      }\n\n      i = -1;\n      continue;\n    }\n  }\n\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\n\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\n\nfunction rectToClientRect(rect) {\n  return { ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n */\nasync function detectOverflow(middlewareArguments, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = middlewareArguments;\n  const {\n    boundary = 'clippingParents',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = options;\n  const paddingObject = getSideObjectFromPadding(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = await platform.getClippingClientRect({\n    element: (await platform.isElement(element)) ? element : element.contextElement || (await platform.getDocumentElement({\n      element: elements.floating\n    })),\n    boundary,\n    rootBoundary\n  });\n  const elementClientRect = rectToClientRect(await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect: elementContext === 'floating' ? { ...rects.floating,\n      x,\n      y\n    } : rects.reference,\n    offsetParent: await platform.getOffsetParent({\n      element: elements.floating\n    }),\n    strategy\n  })); // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  return {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n}\n\nconst min = Math.min;\nconst max = Math.max;\n\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n\n  async fn(middlewareArguments) {\n    // Since `element` is required, we don't Partial<> the type\n    const {\n      element,\n      padding = 0\n    } = options != null ? options : {};\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform\n    } = middlewareArguments;\n\n    if (element == null) {\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n      }\n\n      return {};\n    }\n\n    const paddingObject = getSideObjectFromPadding(padding);\n    const coords = {\n      x,\n      y\n    };\n    const basePlacement = getBasePlacement(placement);\n    const axis = getMainAxisFromPlacement(basePlacement);\n    const length = getLengthFromAxis(axis);\n    const arrowDimensions = await platform.getDimensions({\n      element\n    });\n    const minProp = axis === 'y' ? 'top' : 'left';\n    const maxProp = axis === 'y' ? 'bottom' : 'right';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await platform.getOffsetParent({\n      element\n    });\n    const clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    const centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside of the floating element's bounds\n\n    const min = paddingObject[minProp];\n    const max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = within(min, center, max);\n    return {\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset\n      }\n    };\n  }\n\n});\n\nconst hash$1 = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, matched => hash$1[matched]);\n}\n\nfunction getAlignmentSides(placement, rects) {\n  const isStart = getAlignment(placement) === 'start';\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  let mainAlignmentSide = mainAxis === 'x' ? isStart ? 'right' : 'left' : isStart ? 'bottom' : 'top';\n\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\n\nconst hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, matched => hash[matched]);\n}\n\nconst basePlacements = ['top', 'right', 'bottom', 'left'];\nconst allPlacements = /*#__PURE__*/basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + \"-start\", basePlacement + \"-end\"), []);\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getBasePlacement(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n\n/**\n * Automatically chooses the `placement` which has the most space available.\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'autoPlacement',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _middlewareData$autoP5, _placementsSortedByLe;\n\n      const {\n        x,\n        y,\n        rects,\n        middlewareData,\n        placement\n      } = middlewareArguments;\n      const {\n        alignment = null,\n        allowedPlacements = allPlacements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n\n      if ((_middlewareData$autoP = middlewareData.autoPlacement) != null && _middlewareData$autoP.skip) {\n        return {};\n      }\n\n      const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const currentIndex = (_middlewareData$autoP2 = (_middlewareData$autoP3 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP3.index) != null ? _middlewareData$autoP2 : 0;\n      const currentPlacement = placements[currentIndex];\n      const {\n        main,\n        cross\n      } = getAlignmentSides(currentPlacement, rects); // Make `computeCoords` start from the right place\n\n      if (placement !== currentPlacement) {\n        return {\n          x,\n          y,\n          reset: {\n            placement: placements[0]\n          }\n        };\n      }\n\n      const currentOverflows = [overflow[getBasePlacement(currentPlacement)], overflow[main], overflow[cross]];\n      const allOverflows = [...((_middlewareData$autoP4 = (_middlewareData$autoP5 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP5.overflows) != null ? _middlewareData$autoP4 : []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements[currentIndex + 1]; // There are more placements to check\n\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n\n      const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);\n      const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(_ref => {\n        let {\n          overflows\n        } = _ref;\n        return overflows.every(overflow => overflow <= 0);\n      })) == null ? void 0 : _placementsSortedByLe.placement;\n      return {\n        data: {\n          skip: true\n        },\n        reset: {\n          placement: placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement\n        }\n      };\n    }\n\n  };\n};\n\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'flip',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$flip, _middlewareData$flip2;\n\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement\n      } = middlewareArguments;\n\n      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {\n        return {};\n      }\n\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = options;\n      const basePlacement = getBasePlacement(placement);\n      const isBasePlacement = basePlacement === initialPlacement;\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];\n\n      if (checkMainAxis) {\n        overflows.push(overflow[basePlacement]);\n      }\n\n      if (checkCrossAxis) {\n        const {\n          main,\n          cross\n        } = getAlignmentSides(placement, rects);\n        overflows.push(overflow[main], overflow[cross]);\n      }\n\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }]; // One or more sides is overflowing\n\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip$, _middlewareData$flip3;\n\n        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;\n        const nextPlacement = placements[nextIndex];\n\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        let resetPlacement = 'bottom';\n\n        switch (fallbackStrategy) {\n          case 'bestFit':\n            {\n              var _overflowsData$slice$;\n\n              const placement = (_overflowsData$slice$ = overflowsData.slice().sort((a, b) => a.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0) - b.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;\n\n              if (placement) {\n                resetPlacement = placement;\n              }\n\n              break;\n            }\n\n          case 'initialPlacement':\n            resetPlacement = initialPlacement;\n            break;\n        }\n\n        return {\n          data: {\n            skip: true\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n\n      return {};\n    }\n\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return basePlacements.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n */\n\n\nconst hide = () => ({\n  name: 'hide',\n\n  async fn(modifierArguments) {\n    const referenceOverflow = await detectOverflow(modifierArguments, {\n      elementContext: 'reference'\n    });\n    const floatingAltOverflow = await detectOverflow(modifierArguments, {\n      altBoundary: true\n    });\n    const referenceHiddenOffsets = getSideOffsets(referenceOverflow, modifierArguments.rects.reference);\n    const escapedOffsets = getSideOffsets(floatingAltOverflow, modifierArguments.rects.floating);\n    const referenceHidden = isAnySideFullyClipped(referenceHiddenOffsets);\n    const escaped = isAnySideFullyClipped(escapedOffsets);\n    return {\n      data: {\n        referenceHidden,\n        referenceHiddenOffsets,\n        escaped,\n        escapedOffsets\n      }\n    };\n  }\n\n});\n\nfunction convertValueToCoords(_ref) {\n  let {\n    placement,\n    rects,\n    value\n  } = _ref;\n  const basePlacement = getBasePlacement(placement);\n  const multiplier = ['left', 'top'].includes(basePlacement) ? -1 : 1;\n  const rawValue = typeof value === 'function' ? value({ ...rects,\n    placement\n  }) : value;\n  const {\n    mainAxis,\n    crossAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    ...rawValue\n  };\n  return getMainAxisFromPlacement(basePlacement) === 'x' ? {\n    x: crossAxis,\n    y: mainAxis * multiplier\n  } : {\n    x: mainAxis * multiplier,\n    y: crossAxis\n  };\n}\n/**\n * Displaces the floating element from its reference element.\n */\n\nconst offset = function (value) {\n  if (value === void 0) {\n    value = 0;\n  }\n\n  return {\n    name: 'offset',\n    options: value,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects\n      } = middlewareArguments;\n      const diffCoords = convertValueToCoords({\n        placement,\n        rects,\n        value\n      });\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n\n  };\n};\n\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'shift',\n    options,\n\n    async fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement\n      } = middlewareArguments;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = within(min, mainAxisCoord, max);\n      }\n\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = within(min, crossAxisCoord, max);\n      }\n\n      const limitedCoords = limiter.fn({ ...middlewareArguments,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return { ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options,\n\n    fn(middlewareArguments) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = options;\n      const coords = {\n        x,\n        y\n      };\n      const mainAxis = getMainAxisFromPlacement(placement);\n      const crossAxis = getCrossAxis(mainAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = typeof offset === 'function' ? offset({ ...rects,\n        placement\n      }) : offset;\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;\n\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getBasePlacement(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'size',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$size;\n\n      const {\n        placement,\n        rects,\n        middlewareData\n      } = middlewareArguments;\n      const {\n        apply,\n        ...detectOverflowOptions\n      } = options;\n\n      if ((_middlewareData$size = middlewareData.size) != null && _middlewareData$size.skip) {\n        return {};\n      }\n\n      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);\n      const basePlacement = getBasePlacement(placement);\n      const isEnd = getAlignment(placement) === 'end';\n      let heightSide;\n      let widthSide;\n\n      if (basePlacement === 'top' || basePlacement === 'bottom') {\n        heightSide = basePlacement;\n        widthSide = isEnd ? 'left' : 'right';\n      } else {\n        widthSide = basePlacement;\n        heightSide = isEnd ? 'top' : 'bottom';\n      }\n\n      const xMin = max(overflow.left, 0);\n      const xMax = max(overflow.right, 0);\n      const yMin = max(overflow.top, 0);\n      const yMax = max(overflow.bottom, 0);\n      const dimensions = {\n        height: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n        width: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n      };\n      apply == null ? void 0 : apply({ ...dimensions,\n        ...rects\n      });\n      return {\n        data: {\n          skip: true\n        },\n        reset: {\n          rects: true\n        }\n      };\n    }\n\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: 'inline',\n    options,\n\n    async fn(middlewareArguments) {\n      var _middlewareData$inlin, _await$platform$getCl;\n\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy,\n        middlewareData\n      } = middlewareArguments; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n\n      const {\n        padding = 2,\n        x,\n        y\n      } = options;\n\n      if ((_middlewareData$inlin = middlewareData.inline) != null && _middlewareData$inlin.skip) {\n        return {};\n      }\n\n      const fallback = rectToClientRect(await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n        rect: rects.reference,\n        offsetParent: await platform.getOffsetParent({\n          element: elements.floating\n        }),\n        strategy\n      }));\n      const clientRects = Array.from((_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects({\n        element: elements.reference\n      }))) != null ? _await$platform$getCl : []);\n      const paddingObject = getSideObjectFromPadding(padding);\n\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          var _clientRects$find;\n\n          // Find the first rect in which the point is fully inside\n          return (_clientRects$find = clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;\n        } // There are 2 or more connected rects\n\n\n        if (clientRects.length >= 2) {\n          if (getMainAxisFromPlacement(placement) === 'x') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getBasePlacement(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n\n          const isLeftPlacement = getBasePlacement(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftPlacement ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n\n        return fallback;\n      }\n\n      return {\n        data: {\n          skip: true\n        },\n        reset: {\n          rects: await platform.getElementRects({\n            reference: {\n              getBoundingClientRect\n            },\n            floating: elements.floating,\n            strategy\n          })\n        }\n      };\n    }\n\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };\n","import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return (value == null ? void 0 : value.toString()) === '[object Window]';\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  return {\n    width: clientRect.width / scaleX,\n    height: clientRect.height / scaleY,\n    top: clientRect.top / scaleY,\n    right: clientRect.right / scaleX,\n    bottom: clientRect.bottom / scaleY,\n    left: clientRect.left / scaleX,\n    x: clientRect.left / scaleX,\n    y: clientRect.top / scaleY\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isWindow(element)) {\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n\n    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\nfunction getScrollParents(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollParent = getScrollParent(node);\n  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollParent);\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getScrollParents(getParentNode(target)));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element) {\n  const clientRect = getBoundingClientRect(element);\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingParent(element, clippingParent) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  const clippingParents = getScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingClientRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary\n  } = _ref;\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromClippingParent(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingParent(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nconst platform = {\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: args => convertOffsetParentRelativeRectToViewportRelativeRect(args),\n  getOffsetParent: _ref2 => {\n    let {\n      element\n    } = _ref2;\n    return getOffsetParent(element);\n  },\n  isElement: value => isElement(value),\n  getDocumentElement: _ref3 => {\n    let {\n      element\n    } = _ref3;\n    return getDocumentElement(element);\n  },\n  getClippingClientRect: args => getClippingClientRect(args),\n  getDimensions: _ref4 => {\n    let {\n      element\n    } = _ref4;\n    return getDimensions(element);\n  },\n  getClientRects: _ref5 => {\n    let {\n      element\n    } = _ref5;\n    return element.getClientRects();\n  }\n};\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { computePosition, getScrollParents };\n","import { computePosition, flip, shift, offset, arrow, autoPlacement, hide } from '@floating-ui/dom';\nimport addCSS from './addCSS';\n\nconst addStyles = () => {\n\n  const styles = document.createElement('style');\n  styles.innerText = `\n  #tooltip h3 {\n    text-align: center;\n  }\n  #tooltip p {\n    color: blue;\n  }\n  #tooltip button {\n    border: 1px solid #ccc;\n    background: #eee;\n  }\n  `;\n  document.head.appendChild(styles);\n}\n\n// TODO: Ability to import js bundle without the css\n// TODO: Use debounce to prevent multiple calls for the same event\n// TODO: See all the events and hooks tippyjs uses\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 16;\nconst TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\nexport const createTooltip = async ({ PLACEMENT, OFFSET, tooltip, tip, target, toFlip=true, toShift=true }) => {\n  console.log(`toFlip: ${toFlip}`);\n\n  if(!target) return;\n  const { x, y, placement, middlewareData } = await computePosition(target, tooltip, {\n    placement: PLACEMENT,\n    middleware: [\n      offset({\n        mainAxis: OFFSET[0],\n        crossAxis: OFFSET[1]\n      }),\n      ...PLACEMENT === 'auto' ? [\n        autoPlacement(),\n      ]: [],\n      ...toShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...PLACEMENT !== 'auto' && toFlip ? [\n        flip({\n          fallbackPlacements: ['right', 'left'],\n          fallbackStrategy: 'initialPlacement' // or `bestFit` (when no placement fits perfectly)\n        })\n      ]: [],\n      arrow({\n        element: tip,\n        padding: 2,\n      }),\n      hide()\n    ]\n  });\n\n  const { referenceHidden } = middlewareData.hide!;\n  console.log(`is hidden: ${referenceHidden}`)\n  console.log(middlewareData)\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n\n  Object.assign(tooltip.style, {\n    visibility: referenceHidden ? 'hidden' : 'visible',\n    left: `${x+TIP_SIZE/2}px`, //test\n    top: `${y}px`\n  });\n\n  const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n  let staticSideTipSizeMultiplier;\n  let top;\n  let left;\n  left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n  switch(staticSide) {\n    case 'top':\n      staticSideTipSizeMultiplier = 1/1.7;\n    left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'bottom':\n      staticSideTipSizeMultiplier = 1/2;\n    left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'left':\n      staticSideTipSizeMultiplier = 0.005;\n    left = arrowX !== null ? `${arrowX}px` : \"\",\n    top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n    case 'right':\n      staticSideTipSizeMultiplier = 1.2;\n    left = arrowX !== null ? `${arrowX}px` : \"\",\n    top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n  }\n  top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n  top = arrowY !== null ? `${arrowY}px` : \"\";\n  Object.assign(tip.style, {\n    left,\n    top,\n    right: \"\",\n    bottom: \"\",\n    [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n  });\n}\n\nconst renderTooltip = () => {\n  console.log('this is tooltip lib')\n  const PLACEMENT = \"right\";\n  const OFFSET = [10, 0];\n\n\n  // const target = document.querySelector(\"button.chakra-button\");\n  const target = document.querySelector(\"button#menu-button-2\");\n  // const target = document.querySelectorAll(\"div.chakra-stack\")[3];\n  // const target = document.querySelector(\"select\");\n  const tip = document.createElement(\"div\");\n  const tooltipContent = document.createElement(\"div\");\n  const tooltip = document.createElement(\"div\");\n  addCSS();\n  addStyles();\n\n  tooltipContent.innerHTML = `\n  <div id=\"tooltip-container\">\n  <h3>Tooltip Heading</h3>\n  <!--\n    <p>This is tooltip body text</p>\n  -->\n  <button onclick=\"window.greet()\">Click Me!</button>\n  </div>\n  `;\n\n  tip.id = \"tip\";\n  tooltip.id = \"tooltip\";\n  tooltip.setAttribute('role', 'tooltip');\n  // tooltipContent.innerText = `My tooltip`;\n  tooltip.appendChild(tip);\n  tooltip.appendChild(tooltipContent);\n\n  tooltip.classList.add('popover');\n  tooltipContent.classList.add('popover-content');\n  tip.classList.add('popover-arrow');\n  Object.assign(tooltip.style, {\n    visibility: 'hidden',\n    top: 0,\n    left: 0\n  });\n\n  document.body.appendChild(tooltip);\n\n  window.setTimeout(async() => {\n    await createTooltip({ PLACEMENT, OFFSET, target, tip, tooltip });\n  }, 1000);\n  window.addEventListener('resize', async () => {\n    await createTooltip({ PLACEMENT, OFFSET, target, tip, tooltip, toFlip: false, toShift: false });\n  });\n  window.addEventListener('scroll', async () => {\n    await createTooltip({ PLACEMENT, OFFSET, target, tip, tooltip, toFlip: false, toShift: false });\n  });\n};\n\nexport default renderTooltip;\n","import css from './style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n"],"names":["getBasePlacement","placement","split","getAlignment","getMainAxisFromPlacement","includes","getLengthFromAxis","axis","computeCoordsFromPlacement","_ref","reference","floating","commonX","x","width","commonY","y","height","coords","mainAxis","length","getSideObjectFromPadding","padding","top","right","bottom","left","expandPaddingObject","rectToClientRect","rect","async","detectOverflow","middlewareArguments","options","platform","rects","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingClientRect","isElement","contextElement","getDocumentElement","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","offsetParent","getOffsetParent","min","Math","max","within","min$1","value","max$1","arrow","name","arrowDimensions","getDimensions","minProp","maxProp","endDiff","startDiff","arrowOffsetParent","clientSize","clientHeight","clientWidth","centerToReference","center","offset","data","centerOffset","hash$1","getOppositePlacement","replace","matched","getAlignmentSides","isStart","mainAlignmentSide","main","cross","hash","start","end","getOppositeAlignmentPlacement","basePlacements","allPlacements","reduce","acc","basePlacement","concat","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_middlewareData$autoP3","_middlewareData$autoP4","_middlewareData$autoP5","_placementsSortedByLe","middlewareData","alignment","allowedPlacements","autoAlignment","detectOverflowOptions","skip","placements","filter","getPlacementList","overflow","currentIndex","index","currentPlacement","reset","currentOverflows","allOverflows","overflows","nextPlacement","placementsSortedByLeastOverflow","slice","sort","a","b","placementThatFitsOnAllSides","find","every","flip","_middlewareData$flip","_middlewareData$flip2","initialPlacement","checkMainAxis","crossAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","flipAlignment","oppositePlacement","getExpandedPlacements","overflowsData","push","side","_middlewareData$flip$","_middlewareData$flip3","nextIndex","resetPlacement","_overflowsData$slice$","getSideOffsets","isAnySideFullyClipped","some","fn","diffCoords","multiplier","rawValue","convertValueToCoords","isWindow","toString","getWindow","node","window","ownerDocument","defaultView","getComputedStyle$1","getComputedStyle","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","Element","isShadowRoot","ShadowRoot","isScrollParent","overflowX","overflowY","test","isTableElement","isContainingBlock","isFirefox","navigator","userAgent","css","transform","perspective","contain","willChange","round","getBoundingClientRect","includeScale","clientRect","scaleX","scaleY","offsetWidth","offsetHeight","Node","document","documentElement","getNodeScroll","scrollLeft","pageXOffset","scrollTop","pageYOffset","getWindowScrollBarX","getRectRelativeToOffsetParent","isOffsetParentAnElement","isScaled","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","currentNode","getContainingBlock","getScrollParent","body","getScrollParents","list","_node$ownerDocument","scrollParent","isBody","win","target","visualViewport","updatedList","getClientRectFromClippingParent","clippingParent","html","abs","innerWidth","scale","offsetLeft","offsetTop","getViewportRect","getInnerBoundingClientRect","_element$ownerDocumen","scrollWidth","scrollHeight","direction","getDocumentRect","getClippingParents","clippingParents","clipperElement","parent","child","rootNode","getRootNode","contains","next","getElementRects","args","_ref2","_ref3","firstClippingParent","clippingRect","accRect","_ref4","getClientRects","_ref5","computePosition","config","middleware","statefulPlacement","i","nextX","nextY","computePosition$1","TIP_SIZE","TIP_SIDES_MAP","createTooltip","_a","PLACEMENT","OFFSET","tooltip","tip","_b","toFlip","_c","toShift","console","log","limiter","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","modifierArguments","referenceOverflow","floatingAltOverflow","referenceHiddenOffsets","escapedOffsets","referenceHidden","escaped","_d","_f","hide","arrowX","arrowY","Object","assign","style","visibility","staticSide","staticSideTipSizeMultiplier","defaultStyle","styles","querySelector","createElement","tooltipContent","type","setAttribute","textContent","head","appendChild","innerText","innerHTML","id","classList","add","setTimeout","addEventListener"],"mappings":"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"}