{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/tooltip-element.ts","../src/setTooltipVisibility.ts","../src/floating-ui-tooltip.ts","../src/defaultProps.ts","../src/index.ts","../src/addCSS.ts","../src/debounce.ts"],"sourcesContent":["import { Visibility, TransitionState } from './types';\n\nexport function doesElementHasTransition(element: HTMLElement): boolean {\n    function getCSSPropertyValue(element: HTMLElement, property: string): string {\n        // not working with firefox, pulling property `transition`\n        return window.getComputedStyle(element).getPropertyValue(property);\n    }\n    const transitionDuration = getCSSPropertyValue(element, \"transition-duration\");\n    return !(transitionDuration === \"0s\" || transitionDuration === \"0ms\");\n}\n\nexport function updateTransitionEndListener(\n  root: HTMLDivElement,\n  action: 'add' | 'remove',\n  listener: (event: TransitionEvent) => void\n): void {\n  const method = `${action}EventListener` as\n  | 'addEventListener'\n  | 'removeEventListener';\n\n  [\n    'transitionend',\n    'webkitTransitionEnd',\n    'oTransitionEnd'\n  ].forEach((event) => {\n    root[method](event, listener as EventListener);\n  });\n}\n\nexport function setTransitionState(element: HTMLDivElement, state: TransitionState) {\n  element.setAttribute('data-transition-state', state);\n  console.log('>> new transition state: '+state)\n}\n\nexport function getTransitionState(element: HTMLDivElement): TransitionState {\n  return <TransitionState>element.getAttribute('data-transition-state');\n}\n\nexport function setElementVisibility(tooltipElement: HTMLDivElement, newVisibilityState: Visibility) {\n\n  tooltipElement.setAttribute('data-state', newVisibilityState);\n  Object.assign(tooltipElement.style, {\n    visibility: newVisibilityState,\n  });\n}\n\nexport function onTransitionEnd(element: HTMLDivElement, callback: Function) {\n\n  function listener(e) {\n    if(e.target === element) {\n      updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n      try {\n        callback();\n      } catch (err) {\n        console.error(err);\n        element['_instance'].props.onHide();\n      }\n    }\n  }\n  updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n  updateTransitionEndListener(<HTMLDivElement>element, 'add', listener);\n}\n\nexport function scrollElementIntoView(element: HTMLElement) {\n  element.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  });\n}\n\nexport const isDOMElement = el => el instanceof Element\n","import { setTransitionState, setElementVisibility } from './utils';\n\nexport const NODE_CLASSNAME_PREFIX = 'floating-ui-tooltip';\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nconst createTooltipElement = (instanceEnv): HTMLDivElement => {\n\n  const tooltipRoot = div();\n  const tooltipBox = div();\n  const tooltipContent = div();\n  const arrowElement = div();\n\n  tooltipRoot.className = `${NODE_CLASSNAME_PREFIX}-root`;\n  tooltipBox.className = `${NODE_CLASSNAME_PREFIX}-box`;\n  tooltipContent.className = `${NODE_CLASSNAME_PREFIX}-content`;\n  arrowElement.className = `${NODE_CLASSNAME_PREFIX}-arrow`;\n\n  tooltipBox.appendChild(tooltipContent);\n  tooltipBox.appendChild(arrowElement);\n  tooltipRoot.appendChild(tooltipBox);\n\n  Object.assign(tooltipContent.style, {\n    maxWidth: `${instanceEnv.props.maxWidth}px`\n  })\n\n  tooltipBox.setAttribute('role', 'tooltip');\n  setElementVisibility(tooltipRoot, 'hidden');\n  setTransitionState(tooltipRoot, 'hidden');\n\n  Object.assign(tooltipRoot.style, {\n    zIndex: instanceEnv.props.zIndex,\n    visibility: 'hidden',\n    left: `0px`,\n    top: `0px`\n  });\n  tooltipRoot['_instance'] = instanceEnv;\n  return tooltipRoot;\n}\n\n\nexport interface TooltipElementChildren {\n  box: HTMLDivElement;\n  content: HTMLDivElement;\n  arrow: HTMLDivElement;\n}\n\nexport function getChildren(tooltipElement: Element): TooltipElementChildren {\n  return {\n    box: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-box`)!,\n    content: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-content`)!,\n    arrow: <HTMLDivElement>tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-arrow`) || undefined\n  };\n}\n\nexport default createTooltipElement;\n","import { onTransitionEnd, getTransitionState, setTransitionState, setElementVisibility } from './utils';\nimport { Visibility, TransitionState } from './types';\n\nfunction setTooltipVisibilityState(tooltipElement: HTMLDivElement, visibility: Visibility) {\n  const instance = tooltipElement['_instance'];\n  instance.setState({\n    isShown: visibility === 'visible'\n  });\n}\n\n// console.log = () => {}\n\n// TODO: Any way to preserve the latest caught method call and to plug it at the end in onTransitionEnd callback?\n// -- [IMPORTANT]\nlet LAST_VISIBILITY_STATE: VisibilityState | '' = '';\n// TODO: Maybe just try running this as a debounce method\n// -- debounce method runs the last call right?\n// TODO: This mechanics means ignoring the last call a lot of the times\n\nexport default function setTooltipVisibility(tooltipElement: HTMLDivElement, newVisibilityState: VisibilityState) {\n  const instance = tooltipElement['_instance'];\n  const currentTransitionState: TransitionState = getTransitionState(tooltipElement);\n\n  console.log('``````````')\n  console.log('\\n')\n  console.log(newVisibilityState, currentTransitionState);\n\n  if (newVisibilityState === 'visible') {\n    if (currentTransitionState === 'shown' || currentTransitionState === 'showing') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'hidden') {\n      console.log('showing')\n      LAST_VISIBILITY_STATE = '';\n      setTransitionState(tooltipElement, 'showing');\n      // proceed to show\n\n    } else if (currentTransitionState === 'hiding') {\n      console.log(`cancelling ${currentTransitionState}`)\n      LAST_VISIBILITY_STATE = newVisibilityState;\n      // NOTE: where should this be again?^\n      return;\n    }\n  } else {\n    if (currentTransitionState === 'hidden' || currentTransitionState === 'hiding') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'shown') {\n      LAST_VISIBILITY_STATE = '';\n      setTransitionState(tooltipElement, 'hiding');\n      instance.props.onHide(instance);\n      // proceed to hide\n\n    } else if (currentTransitionState === 'showing') {\n      console.log(`cancelling ${currentTransitionState}`)\n      LAST_VISIBILITY_STATE = newVisibilityState;\n      return;\n    }\n  }\n  const newTransitionState = newVisibilityState === 'visible' ? 'shown' : 'hidden';\n\n  if (instance.transitionDuration !== 0) {\n    onTransitionEnd(tooltipElement, () => {\n      setTooltipVisibilityState(tooltipElement, newVisibilityState);\n      setTransitionState(tooltipElement, newTransitionState);\n\n      newVisibilityState === 'visible' && instance.props.onShow(instance);\n      /* if (LAST_VISIBILITY_STATE) {\n        console.log('LAST EVENT FIRED')\n        setTooltipVisibility(tooltipElement, LAST_VISIBILITY_STATE);\n      } */\n    });\n\n    setElementVisibility(tooltipElement, newVisibilityState);\n  } else {\n    setElementVisibility(tooltipElement, newVisibilityState);\n    setTransitionState(tooltipElement, newTransitionState);\n    newVisibilityState === 'visible' && instance.props.onShow(instance);\n  }\n  // for hiding: run onHide hook before dom change\n  // for showing: make dom change before running onShow\n}\n","import {\n  computePosition,\n  size,\n  flip,\n  shift,\n  offset,\n  arrow,\n  autoPlacement,\n  hide,\n} from '@floating-ui/dom';\nimport { getChildren } from './tooltip-element';\nimport { Props, TooltipState, Visibility, Placement, Position } from './types';\nimport { scrollElementIntoView } from './utils';\nimport setTooltipVisibility from './setTooltipVisibility';\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 2;\nconst DEFAULT_TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * DEFAULT_TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\nconst isElementOverflowingDocument = (element) => {\n  const elementRect = element.getBoundingClientRect();\n  const documentRect = document.documentElement.getBoundingClientRect();\n  return elementRect.top < documentRect.top ||\n    elementRect.bottom > documentRect.bottom ||\n    elementRect.left < documentRect.left ||\n    elementRect.right > documentRect.right;\n}\n\nconst getPosition = ({ passedPlacement, tooltipElement, toResetPosition }): Position => {\n  const {\n    orientation\n  } = passedPlacement;\n\n  const currentPosition = tooltipElement['_instance'].state.fui?.placement;\n  if (!currentPosition){\n    return passedPlacement.position;\n  }\n\n  if (!toResetPosition) return currentPosition;\n  if (isElementOverflowingDocument(tooltipElement)) {\n    console.log('tooltip overflown')\n    if (orientation === 'auto') {\n      return 'auto';\n    }\n  } else {\n    // console.log('tooltip not overflown')\n  }\n  return currentPosition;\n}\n\nconst renderTooltip = ({ fui, newlyShown, scrollIntoView, hideOnReferenceHidden, hideOnTooltipEscape, tooltipElement, arrowElement, target, toHide, showOnCreate, arrowSizeScale }) => {\n  const { x, y, placement, middlewareData } = fui;\n\n  const { referenceHidden, escaped } = middlewareData.hide!;\n\n  if (referenceHidden && newlyShown && scrollIntoView) {\n    scrollElementIntoView(target);\n  }\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n  const arrowOffCenter = middlewareData.arrow!.centerOffset !== 0;\n\n  let visibility: Visibility = ((\n    hideOnReferenceHidden && referenceHidden)\n    || (hideOnTooltipEscape && escaped)\n    || toHide) ? 'hidden' : 'visible' as const;\n\n    console.log(`to change visibility to: ${visibility}`)\n\n    if (visibility === 'visible' && newlyShown && !showOnCreate){\n      visibility = 'hidden' as const;\n    }\n    /* console.log(hideOnReferenceHidden && referenceHidden, hideOnTooltipEscape && escaped, toHide)\n       console.log(visibility); */\n\n    setTooltipVisibility(<HTMLDivElement>tooltipElement, visibility);\n\n    Object.assign(tooltipElement.style, {\n      left: `${x}px`,\n      top: `${y}px`\n    });\n\n    const TIP_SIZE = arrowSizeScale * DEFAULT_TIP_SIZE;\n\n    const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n    let staticSideTipSizeMultiplier: string | number = 0;\n    let top: string | number = 0;\n    let left: string | number = 0;\n    left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n    switch(staticSide) {\n      case 'top':\n        staticSideTipSizeMultiplier = 1/1.7;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n      break;\n      case 'bottom':\n        staticSideTipSizeMultiplier = 1/2;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n      break;\n      case 'left':\n        staticSideTipSizeMultiplier = 0.005;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n      break;\n      case 'right':\n        staticSideTipSizeMultiplier = 1.2;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n      break;\n    }\n\n    top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n    top = arrowY !== null ? `${arrowY}px` : \"\";\n    Object.assign(arrowElement.style, {\n      visibility: arrowOffCenter ? 'hidden' : 'visible',\n      left,\n      top,\n      right: \"\",\n      bottom: \"\",\n      [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n    });\n}\n\nconst computeTooltip = async ({ passedPlacement, toResetPosition, passedOffset, resetPlacementOnUpdate, newlyShown, toShift, toShowArrow, arrowElement, tooltipElement, target }) => {\n\n  const position = getPosition({\n    passedPlacement,\n    tooltipElement,\n    toResetPosition\n  });\n\n  const toEnableAutoPlacement = position === 'auto' && (newlyShown || resetPlacementOnUpdate);\n  const toEnableShift = toShift && newlyShown;\n\n  const computePositionConfig = {\n    ...position !== 'auto' && {\n      placement: position,\n    },\n    middleware: [\n      offset({\n        mainAxis: passedOffset[0],\n        crossAxis: passedOffset[1]\n      }),\n      ...toEnableAutoPlacement ? [\n        autoPlacement(),\n      ]: [],\n      ...toEnableShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...toShowArrow ? [\n        arrow({\n          element: arrowElement,\n          padding: TIP_EDGE_MARGIN,\n        })\n      ]: [],\n      size({\n        apply({width, height, reference, floating}) {\n        }\n      }),\n      hide()\n    ]\n  }\n  return await computePosition(target, tooltipElement, computePositionConfig);\n}\n\nconst floatingUITooltip = async (\n  tooltipProps: Props,\n  tooltipElement: HTMLElement,\n  target: HTMLElement,\n  toHide: boolean,\n  toResetPosition: boolean | undefined,\n  setState: (state: Partial<TooltipState>)=> void\n) => {\n  const { toFlip=false, toShift=true } = {};\n\n  let {\n    placement: passedPlacement,\n    hideOnReferenceHidden,\n    offset: passedOffset,\n    hideOnTooltipEscape,\n    arrowSizeScale,\n    resetPlacementOnUpdate,\n    arrow: toShowArrow,\n    scrollIntoView,\n    showOnCreate\n  } = tooltipProps;\n\n  const { arrow: arrowElement } = getChildren(tooltipElement);\n  const newlyShown = !tooltipElement['_instance'].getState().fui;\n\n\n  if(!target) {\n    return console.warn('target element not found');\n  }\n\n  let fui = await computeTooltip({ passedPlacement, toResetPosition, passedOffset, resetPlacementOnUpdate, toShift, toShowArrow, arrowElement, tooltipElement, target, newlyShown });\n\n  renderTooltip({ fui, newlyShown, scrollIntoView, hideOnReferenceHidden, hideOnTooltipEscape, tooltipElement, arrowElement, target, toHide, showOnCreate, arrowSizeScale });\n\n  setState({\n    fui\n  });\n  return fui;\n}\n\nexport default floatingUITooltip;\n","import { Instance, TooltipState } from './types';\n\nconst defaultProps = {\n  allowHTML: true,\n  content: '',\n  arrow: true,\n  scrollIntoView: false,\n  transitionDuration: [300, 250],\n  offset: [10, 0],\n  hideOnClick: true, // `true` for anywhere outside the tooltip to hide it, 'target' for only when the target is clicked\n  onClickOutside: (instance: Instance, event: MouseEvent) => {},\n  onShow: (instance: Instance) => {},\n  onHide: (instance: Instance) => {},\n  onStateChange: (oldState: TooltipState, newState: Partial<TooltipState>) => {},\n  onRemove: () => {},\n  onBeforeFirstRender: () => {},\n  onAfterFirstRender: () => {},\n  placement: {\n    position: 'top',\n    orientation: 'fixed'\n  },\n  resetPlacementOnUpdate: false,\n  hideOnTooltipEscape: true,\n  hideOnReferenceHidden: true,\n  showOnCreate: true,\n  maxWidth: 350,\n  updateDebounce: 100,\n  zIndex: 99999,\n  arrowSizeScale: 1,\n  updateOnEvents: 'resize scroll'\n}\n\nexport default defaultProps;\n","import createTooltipElement, { getChildren } from './tooltip-element';\nimport addCSS from './addCSS';\nimport { Props, TooltipState, Instance } from './types';\nimport floatingUITooltip from './floating-ui-tooltip';\nimport defaultProps from './defaultProps';\nimport { scrollElementIntoView } from './utils';\nimport debounce from './debounce';\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: Ability to import js bundle without the css\n// TODO: Add ability to pass dom element as content\n\nconst appendTo = () => document.body;\n\nclass Tooltip {\n  readonly props: Props;\n  readonly reference: HTMLElement;\n  public tooltipElement!: HTMLDivElement;\n  private state: TooltipState = {\n    isShown: false,\n    isRemoved: false,\n    fui: undefined\n  }\n  private updateListenerCleanup: () => void = () => {};\n  private toHideTooltip: boolean = false;\n  private debouncedUpdate!: (arg: boolean | undefined) => void;\n  private transitionDuration: number = 0;\n\n  constructor(props: Props, target: HTMLElement) {\n    this.props = props;\n    // this.props.updateDebounce = 0; // test\n    this.reference = target;\n    window['tp'] = this;\n    addCSS();\n    this.toHideTooltip = !this.props.showOnCreate;\n  }\n\n  private hookEventListeners() {\n    this.debouncedUpdate = debounce(\n      this.update.bind(this),\n      this.props.updateDebounce\n    );\n    const autoUpdateCleanup = autoUpdate(\n      this.reference,\n      this.tooltipElement,\n      () => this.debouncedUpdate(undefined),\n    );\n\n    const debouncedUpdateHandler = () =>\n      this.debouncedUpdate(undefined) as unknown as EventListenerOrEventListenerObject;\n\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.addEventListener(\n        <keyof WindowEventMap>event,\n        debouncedUpdateHandler\n      );\n    });\n    window.addEventListener('click', this.clickHandler.bind(this));\n\n    // prepare event listeners' cleanup method\n    this.updateListenerCleanup = () => {\n      autoUpdateCleanup();\n      window.removeEventListener('click', this.clickHandler.bind(this));\n\n      this.props.updateOnEvents.split(' ').forEach(event => {\n        window.removeEventListener(\n          <keyof WindowEventMap>event,\n          debouncedUpdateHandler\n        );\n      });\n    }\n  }\n\n  private clickHandler = (event: MouseEvent) => {\n    if (!this.state.isShown) return;\n\n    // if click is outside of tooltip and reference\n    if (\n      !this.tooltipElement.contains(event.target as Node) &&\n      !this.reference.contains(event.target as Node)\n    ) {\n      if (this.props.onClickOutside) {\n        this.props.onClickOutside(this, event);\n      }\n    }\n\n    if (this.props.hideOnClick === 'target') {\n      if (event.target === this.reference) {\n        this.hide();\n      }\n    } else if (this.props.hideOnClick) {\n      this.hide();\n    }\n  }\n\n  private updateTransitionDuration(duration: number) {\n    this.transitionDuration = duration;\n    this.tooltipElement.style.transitionDuration = `${duration}ms`;\n  }\n\n  public async create() {\n    this.tooltipElement = createTooltipElement(this);\n    this.updateTransitionDuration(\n      this.props.transitionDuration[this.toHideTooltip ? 0 : 1]\n    );\n    const { content: contentBox } = getChildren(this.tooltipElement);\n    const { allowHTML, content } = this.props;\n    if (allowHTML) {\n      if (content instanceof Element) {\n        contentBox.appendChild(content);\n      } else {\n        contentBox.innerHTML = content;\n      }\n    } else {\n      if (!(content instanceof Element)) {\n        contentBox.innerText = content;\n      }\n    }\n\n    appendTo().appendChild(this.tooltipElement);\n    this.props.onBeforeFirstRender();\n\n    const initFloatingUI = async () => {\n      await floatingUITooltip(\n        this.props,\n        this.tooltipElement,\n        this.reference,\n        this.toHideTooltip,\n        true,\n        this.setState.bind(this),\n      );\n      await this.update(false, true);\n      await this.update(false, true);\n      this.hookEventListeners();\n    }\n    await initFloatingUI();\n    if(this.props.showOnCreate){\n      await this.show();\n    } else {\n      await this.hide();\n    }\n    this.props.onAfterFirstRender();\n  }\n\n  public getState(): TooltipState {\n    return this.state;\n  }\n\n  private setState(newState: Partial<TooltipState>) {\n    const visibilityChanged = typeof newState.isShown !== 'undefined' &&\n      newState.isShown !== this.state.isShown;\n\n    if (visibilityChanged) {\n      this.updateTransitionDuration(\n        this.props.transitionDuration[newState.isShown ? 1 : 0]\n      );\n    }\n\n    this.props.onStateChange(this.state, newState);\n\n    this.state = {\n      ...this.state,\n      ...newState\n    }\n  }\n\n  public async update(toHide?: boolean, toResetPosition?: boolean) {\n    toHide = toHide || this.toHideTooltip || false;\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      toResetPosition,\n      this.setState.bind(this)\n    );\n  }\n\n  public async hide() {\n    // hide() when tooltip is already hidden should prevent event listeners\n    // from showing tooltip without before running show() manually\n    this.toHideTooltip = true;\n    await this.update(true);\n  }\n\n  public async show() {\n    // console.log(`show() ran with resetPosition: ${resetPosition}`);\n    this.toHideTooltip = false;\n    await this.update(false);\n  }\n\n  public remove() {\n    this.tooltipElement.remove();\n    this.state = {\n      isShown: false,\n      isRemoved: true,\n      fui: undefined\n    }\n    this.updateListenerCleanup();\n    console.log('removed all event listeners and observers');\n    this.props.onRemove();\n  }\n}\n\nfunction isElementInViewport (el) {\n  const rect = el.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && /* or $(window).height() */\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth) /* or $(window).width() */\n  );\n}\n\nasync function createTooltip(\n  reference: HTMLElement,\n  props: Partial<Props>\n): Promise<Instance> {\n  const placement = props.placement || defaultProps.placement;\n  const transitionDuration = props.transitionDuration || defaultProps.transitionDuration;\n  const offset = props.offset || defaultProps.offset;\n\n  // NOTE: Interesting that the properties with undefined values still won't be replaced...\n  // -- Relevant to Lusift?\n\n  // remove properties with value of undefined\n  Object.keys(props).forEach(key => props[key] === undefined && delete props[key])\n\n  const allProps: Props = {\n    ...defaultProps,\n    ...props,\n    placement: <Props['placement']>placement,\n    transitionDuration: <Props['transitionDuration']>transitionDuration,\n    offset: <Props['offset']>offset,\n  };\n  const tooltipInstance = new Tooltip(allProps, reference);\n\n  await tooltipInstance.create();\n\n  const instance: Instance = {\n    props: tooltipInstance.props,\n    reference: tooltipInstance.reference,\n    tooltipElement: tooltipInstance.tooltipElement,\n    getState: tooltipInstance.getState.bind(tooltipInstance),\n    show: tooltipInstance.show.bind(tooltipInstance),\n    hide: tooltipInstance.hide.bind(tooltipInstance),\n    remove: tooltipInstance.remove.bind(tooltipInstance),\n    update: tooltipInstance.update.bind(tooltipInstance),\n  }\n\n  return instance;\n}\n\nexport default createTooltip;\n","import css from './css/style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n"],"names":["updateTransitionEndListener","root","action","listener","method","forEach","event","setTransitionState","element","state","setAttribute","console","log","setElementVisibility","tooltipElement","newVisibilityState","Object","assign","style","visibility","div","document","createElement","getChildren","box","querySelector","content","arrow","undefined","setTooltipVisibility","instance","currentTransitionState","getAttribute","props","onHide","newTransitionState","transitionDuration","callback","e","target","err","error","onTransitionEnd","setState","isShown","setTooltipVisibilityState","onShow","TIP_SIDES_MAP","top","right","bottom","left","getPosition","_a","elementRect","documentRect","passedPlacement","toResetPosition","orientation","currentPosition","fui","placement","getBoundingClientRect","documentElement","position","computeTooltip","passedOffset","resetPlacementOnUpdate","newlyShown","toShift","toShowArrow","arrowElement","toEnableAutoPlacement","toEnableShift","computePositionConfig","middleware","offset","mainAxis","crossAxis","autoPlacement","shift","padding","size","apply","hide","computePosition","_b","floatingUITooltip","tooltipProps","toHide","_c","hideOnReferenceHidden","hideOnTooltipEscape","arrowSizeScale","scrollIntoView","showOnCreate","getState","warn","arrowX","arrowY","x","y","middlewareData","referenceHidden","escaped","behavior","block","inline","arrowOffCenter","centerOffset","TIP_SIZE","staticSide","split","staticSideTipSizeMultiplier","renderTooltip","_d","defaultProps","allowHTML","hideOnClick","onClickOutside","onStateChange","oldState","newState","onRemove","onBeforeFirstRender","onAfterFirstRender","maxWidth","updateDebounce","zIndex","updateOnEvents","defaultStyle","this","isRemoved","_this","contains","reference","window","type","textContent","head","appendChild","toHideTooltip","Tooltip","fn","ms","timeout","debouncedUpdate","update","bind","arg","clearTimeout","setTimeout","autoUpdateCleanup","autoUpdate","debouncedUpdateHandler","addEventListener","clickHandler","updateListenerCleanup","removeEventListener","duration","instanceEnv","tooltipRoot","tooltipBox","tooltipContent","className","NODE_CLASSNAME_PREFIX","updateTransitionDuration","contentBox","Element","innerHTML","innerText","body","initFloatingUI","hookEventListeners","show","remove","keys","key","allProps","tooltipInstance","create"],"mappings":"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"}