{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/tooltip-element.ts","../src/setTooltipVisibility.ts","../src/floating-ui-tooltip.ts","../src/defaultProps.ts","../src/index.ts","../src/addCSS.ts","../src/debounce.ts"],"sourcesContent":["import { Visibility, TransitionState } from './types';\n\nexport function doesElementHasTransition(element: HTMLElement): boolean {\n    function getCSSPropertyValue(element: HTMLElement, property: string): string {\n        // not working with firefox, pulling property `transition`\n        return window.getComputedStyle(element).getPropertyValue(property);\n    }\n    const transitionDuration = getCSSPropertyValue(element, \"transition-duration\");\n    return !(transitionDuration === \"0s\" || transitionDuration === \"0ms\");\n}\n\nexport function updateTransitionEndListener(\n  root: HTMLDivElement,\n  action: 'add' | 'remove',\n  listener: (event: TransitionEvent) => void\n): void {\n  const method = `${action}EventListener` as\n  | 'addEventListener'\n  | 'removeEventListener';\n\n  [\n    'transitionend',\n    'webkitTransitionEnd',\n    'oTransitionEnd'\n  ].forEach((event) => {\n    root[method](event, listener as EventListener);\n  });\n}\n\nexport function setTransitionState(element: HTMLDivElement, state: TransitionState) {\n  element.setAttribute('data-transition-state', state);\n  console.log('>> new transition state: '+state)\n}\n\nexport function getTransitionState(element: HTMLDivElement): TransitionState {\n  return <TransitionState>element.getAttribute('data-transition-state');\n}\n\nexport function setElementVisibility(tooltipElement: HTMLDivElement, newVisibilityState: Visibility) {\n\n  tooltipElement.setAttribute('data-state', newVisibilityState);\n  Object.assign(tooltipElement.style, {\n    visibility: newVisibilityState,\n  });\n}\n\nexport function onTransitionEnd(element: HTMLDivElement, callback: Function) {\n\n  function listener(e) {\n    if(e.target === element) {\n      updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n      try {\n        callback();\n      } catch (err) {\n        console.error(err);\n        element['_instance'].props.onHide();\n      }\n    }\n  }\n  updateTransitionEndListener(<HTMLDivElement>element, 'remove', listener);\n  updateTransitionEndListener(<HTMLDivElement>element, 'add', listener);\n}\n\nexport function scrollElementIntoView(element: HTMLElement) {\n  element.scrollIntoView({\n    behavior: \"smooth\",\n    block: \"center\",\n    inline: \"center\",\n  });\n}\n","import { setTransitionState, setElementVisibility } from './utils';\n\nexport const NODE_CLASSNAME_PREFIX = 'floating-ui-tooltip';\n\nexport function div(): HTMLDivElement {\n  return document.createElement('div');\n}\n\nconst createTooltipElement = (instanceEnv): HTMLDivElement => {\n\n  const tooltipRoot = div();\n  const tooltipBox = div();\n  const tooltipContent = div();\n  const arrowElement = div();\n\n  tooltipRoot.className = `${NODE_CLASSNAME_PREFIX}-root`;\n  tooltipBox.className = `${NODE_CLASSNAME_PREFIX}-box`;\n  tooltipContent.className = `${NODE_CLASSNAME_PREFIX}-content`;\n  arrowElement.className = `${NODE_CLASSNAME_PREFIX}-arrow`;\n\n  tooltipBox.appendChild(tooltipContent);\n  tooltipBox.appendChild(arrowElement);\n  tooltipRoot.appendChild(tooltipBox);\n\n  Object.assign(tooltipContent.style, {\n    maxWidth: `${instanceEnv.props.maxWidth}px`\n  })\n  tooltipContent.innerHTML = `\n    <div id=\"tooltip-container\">\n    <h3>Default tooltip</h3>\n    </div>\n  `;\n\n  tooltipBox.setAttribute('role', 'tooltip');\n  setElementVisibility(tooltipRoot, 'hidden');\n  setTransitionState(tooltipRoot, 'hidden');\n\n  Object.assign(tooltipRoot.style, {\n    zIndex: instanceEnv.props.zIndex,\n    visibility: 'hidden',\n    left: `0px`,\n    top: `0px`\n  });\n  tooltipRoot['_instance'] = instanceEnv;\n  return tooltipRoot;\n}\n\n\nexport interface TooltipElementChildren {\n  box: HTMLDivElement;\n  content: HTMLDivElement;\n  arrow: HTMLDivElement;\n}\n\nexport function getChildren(tooltipElement: Element): TooltipElementChildren {\n  return {\n    box: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-box`)!,\n    content: tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-content`)!,\n    arrow: <HTMLDivElement>tooltipElement.querySelector(`.${NODE_CLASSNAME_PREFIX}-arrow`) || undefined\n  };\n}\n\nexport default createTooltipElement;\n","import { onTransitionEnd, getTransitionState, setTransitionState, setElementVisibility } from './utils';\nimport { Visibility, TransitionState } from './types';\n\nfunction setTooltipVisibilityState(tooltipElement: HTMLDivElement, visibility: Visibility) {\n  const instance = tooltipElement['_instance'];\n  instance.setState({\n    isShown: visibility === 'visible'\n  });\n}\n\n// TODO: Any way to preserve the latest caught method call and to plug it at the end in onTransitionEnd callback?\n// -- [IMPORTANT]\nlet LAST_VISIBILITY_STATE: VisibilityState | '' = '';\n// TODO: Maybe just try running this as a debounce method\n// -- debounce method runs the last call right?\n\nexport default function setTooltipVisibility(tooltipElement: HTMLDivElement, newVisibilityState: VisibilityState) {\n  const instance = tooltipElement['_instance'];\n  const currentTransitionState: TransitionState = getTransitionState(tooltipElement);\n\n  console.log('``````````')\n  console.log('\\n')\n  console.log(newVisibilityState, currentTransitionState);\n\n  if (newVisibilityState === 'visible') {\n    if (currentTransitionState === 'shown' || currentTransitionState === 'showing') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'hidden') {\n      console.log('showing')\n      LAST_VISIBILITY_STATE = '';\n      setTransitionState(tooltipElement, 'showing');\n      // proceed to show\n\n    } else if (currentTransitionState === 'hiding') {\n      console.log(`cancelling ${currentTransitionState}`)\n      LAST_VISIBILITY_STATE = newVisibilityState;\n      // NOTE: where should this be again?^\n      return;\n    }\n  } else {\n    if (currentTransitionState === 'hidden' || currentTransitionState === 'hiding') {\n      console.log(`already ${currentTransitionState}`)\n      return;\n\n    } else if (currentTransitionState === 'shown') {\n      LAST_VISIBILITY_STATE = '';\n      setTransitionState(tooltipElement, 'hiding');\n      instance.props.onHide(instance);\n      // proceed to hide\n\n    } else if (currentTransitionState === 'showing') {\n      console.log(`cancelling ${currentTransitionState}`)\n      LAST_VISIBILITY_STATE = newVisibilityState;\n      return;\n    }\n  }\n  const newTransitionState = newVisibilityState === 'visible' ? 'shown' : 'hidden';\n\n  if (instance.transitionDuration !== 0) {\n    onTransitionEnd(tooltipElement, () => {\n      setTooltipVisibilityState(tooltipElement, newVisibilityState);\n      setTransitionState(tooltipElement, newTransitionState);\n\n      newVisibilityState === 'visible' && instance.props.onShow(instance);\n      /* if (LAST_VISIBILITY_STATE) {\n        console.log('LAST EVENT FIRED')\n        setTooltipVisibility(tooltipElement, LAST_VISIBILITY_STATE);\n      } */\n    });\n\n    setElementVisibility(tooltipElement, newVisibilityState);\n  } else {\n    setElementVisibility(tooltipElement, newVisibilityState);\n    setTransitionState(tooltipElement, newTransitionState);\n    newVisibilityState === 'visible' && instance.props.onShow(instance);\n  }\n  // for hiding: run onHide hook before dom change\n  // for showing: make dom change before running onShow\n}\n","import {\n  computePosition,\n  size,\n  flip,\n  shift,\n  offset,\n  arrow,\n  autoPlacement,\n  hide,\n} from '@floating-ui/dom';\nimport { getChildren } from './tooltip-element';\nimport { Props, TooltipState, Visibility, Placement, Position } from './types';\nimport { scrollElementIntoView } from './utils';\nimport setTooltipVisibility from './setTooltipVisibility';\n\nconst SCREEN_EDGE_MARGIN = 16;\nconst TIP_EDGE_MARGIN = 2;\nconst DEFAULT_TIP_SIZE = 12;\nconst TIP_WIDTH = Math.sqrt(2 * DEFAULT_TIP_SIZE ** 2) / 2;\n\nconst TIP_SIDES_MAP = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\n\nconst getPosition = ({ passedPlacement, fui }): Position => {\n  const {\n    position,\n    orientation\n  } = passedPlacement;\n  if (!fui) return position;\n  const { x, y } = fui;\n  if (position !== 'auto' && (x < 0 || y < 0)) {\n    if (orientation === 'auto') {\n      return 'auto';\n    }\n  }\n  return position;\n}\n\nconst floatingUITooltip = async (\n  tooltipProps: Props,\n  tooltipElement: HTMLElement,\n  target: HTMLElement,\n  toHide: boolean,\n  newlyShown: boolean,\n  setState: (state: Partial<TooltipState>)=> void\n) => {\n const { toFlip=false, toShift=true } = {};\n\n  let {\n    placement: passedPlacement,\n    hideOnReferenceHidden,\n    offset: passedOffset,\n    hideOnTooltipEscape,\n    arrowSizeScale,\n    resetPlacementOnUpdate,\n    arrow: toShowArrow,\n    scrollIntoView,\n    showOnCreate\n  } = tooltipProps;\n\n  const { arrow: arrowElement } = getChildren(tooltipElement);\n  const TIP_SIZE = arrowSizeScale * DEFAULT_TIP_SIZE;\n\n\n  if(!target) return;\n\n  const position = getPosition({\n    passedPlacement,\n    fui: tooltipElement['_instance'].state.fui\n  });\n\n  const toEnableAutoPlacement = position === 'auto' && (newlyShown || resetPlacementOnUpdate);\n  const toEnableShift = toShift && newlyShown;\n\n  // TODO: we want to be able to take any placement including auto, and also\n  // orientation of `fixed` or `auto`\n  // -- if passedPlacement is other than auto, and orientation is auto\n  // -- -- if x or y is in negative, we make placement auto\n\n  const computePositionConfig = {\n    ...position !== 'auto' && {\n      placement: position,\n    },\n    middleware: [\n      offset({\n        mainAxis: passedOffset[0],\n        crossAxis: passedOffset[1]\n      }),\n      ...toEnableAutoPlacement ? [\n        autoPlacement(),\n      ]: [],\n      ...toEnableShift ? [\n        shift({ padding: SCREEN_EDGE_MARGIN }),\n      ]: [],\n      ...toShowArrow ? [\n        arrow({\n          element: arrowElement,\n          padding: TIP_EDGE_MARGIN,\n        })\n      ]: [],\n      size({\n        apply({width, height, reference, floating}) {\n        }\n      }),\n      hide()\n    ]\n  }\n\n  console.log(`computePositionConfig`)\n  console.log(computePositionConfig);\n\n  const fui = await computePosition(target, tooltipElement, computePositionConfig);\n  const { x, y, placement, middlewareData } = fui;\n\n  const { referenceHidden, escaped } = middlewareData.hide!;\n\n  if (referenceHidden && newlyShown && scrollIntoView) {\n    scrollElementIntoView(target);\n  }\n\n  let arrowX,\n  arrowY;\n  if(middlewareData.arrow){\n    arrowX = middlewareData.arrow.x;\n    arrowY = middlewareData.arrow.y;\n  }\n  const arrowOffCenter = middlewareData.arrow!.centerOffset !== 0;\n\n  let visibility: Visibility = ((\n    hideOnReferenceHidden && referenceHidden)\n    || (hideOnTooltipEscape && escaped)\n    || toHide) ? 'hidden' : 'visible' as const;\n\n  if (visibility === 'visible' && newlyShown && !showOnCreate){\n    visibility = 'hidden' as const;\n  }\n  /* console.log(hideOnReferenceHidden && referenceHidden, hideOnTooltipEscape && escaped, toHide)\n  console.log(visibility); */\n\n  setTooltipVisibility(<HTMLDivElement>tooltipElement, visibility);\n\n  Object.assign(tooltipElement.style, {\n    left: `${x}px`,\n    top: `${y}px`\n  });\n\n  const staticSide = TIP_SIDES_MAP[placement.split(\"-\")[0]];\n  let staticSideTipSizeMultiplier: string | number = 0;\n  let top: string | number = 0;\n  let left: string | number = 0;\n  left = arrowX !== null ? `${arrowX + (TIP_SIZE)}px` : \"\";\n\n  switch(staticSide) {\n    case 'top':\n      staticSideTipSizeMultiplier = 1/1.7;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'bottom':\n      staticSideTipSizeMultiplier = 1/2;\n      left = arrowX !== null ? `${arrowX + (TIP_SIZE*staticSideTipSizeMultiplier)}px` : \"\";\n    break;\n    case 'left':\n      staticSideTipSizeMultiplier = 0.005;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n    case 'right':\n      staticSideTipSizeMultiplier = 1.2;\n      left = arrowX !== null ? `${arrowX}px` : \"\",\n      top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n    break;\n  }\n\n  top = arrowY !== null ? `${arrowY - (TIP_SIZE*staticSideTipSizeMultiplier)/2}px` : \"\";\n\n  top = arrowY !== null ? `${arrowY}px` : \"\";\n  Object.assign(arrowElement.style, {\n    visibility: arrowOffCenter ? 'hidden' : 'visible',\n    left,\n    top,\n    right: \"\",\n    bottom: \"\",\n    [staticSide]: `-${TIP_SIZE*staticSideTipSizeMultiplier}px`\n  });\n\n  setState({\n    fui\n  });\n\n  return fui;\n}\n\nexport default floatingUITooltip;\n","import { Instance, TooltipState } from './types';\n\nconst defaultProps = {\n  allowHTML: true,\n  content: '',\n  arrow: true,\n  scrollIntoView: false,\n  transitionDuration: [300, 250],\n  offset: [10, 0],\n  hideOnClick: true, // `true` for anywhere outside the tooltip to hide it, 'target' for only when the target is clicked\n  onClickOutside: (instance: Instance, event: MouseEvent) => {},\n  onShow: (instance: Instance) => {},\n  onHide: (instance: Instance) => {},\n  onStateChange: (oldState: TooltipState, newState: Partial<TooltipState>) => {},\n  onRemove: () => {},\n  placement: {\n    position: 'top',\n    orientation: 'fixed'\n  },\n  resetPlacementOnUpdate: false,\n  hideOnTooltipEscape: true,\n  hideOnReferenceHidden: true,\n  showOnCreate: true,\n  maxWidth: 350,\n  updateDebounce: 100,\n  zIndex: 99999,\n  arrowSizeScale: 1,\n  updateOnEvents: 'resize scroll'\n}\n\nexport default defaultProps;\n","import createTooltipElement, { getChildren } from './tooltip-element';\nimport addCSS from './addCSS';\nimport { Props, TooltipState, Instance } from './types';\nimport floatingUITooltip from './floating-ui-tooltip';\nimport defaultProps from './defaultProps';\nimport debounce from './debounce';\nimport { autoUpdate } from '@floating-ui/dom';\n\n// TODO: Ability to import js bundle without the css\n// NOTE: Should the tooltip be appended to the body?\n// -- https://web.archive.org/web/20210827084020/https://atfzl.com/don-t-attach-tooltips-to-document-body\n\nconst appendTo = () => document.body;\n\nclass Tooltip {\n  readonly props: Props;\n  readonly reference: HTMLElement;\n  public tooltipElement!: HTMLDivElement;\n  private state: TooltipState = {\n    isShown: false,\n    isRemoved: false,\n    fui: undefined\n  }\n  private updateListenerCleanup: () => void = () => {};\n  private toHideTooltip: boolean = false;\n  private debouncedUpdate!: (arg: boolean | undefined) => void;\n  private transitionDuration: number = 0;\n\n  constructor(props: Props, target: HTMLElement) {\n    this.props = props;\n    // this.props.updateDebounce = 0; // test\n    this.reference = target;\n    // window['tp'] = this;\n    addCSS();\n    this.toHideTooltip = !this.props.showOnCreate;\n  }\n\n  private hookEventListeners() {\n    this.debouncedUpdate = debounce(\n      this.update.bind(this),\n      this.props.updateDebounce\n    );\n    const autoUpdateCleanup = autoUpdate(\n      this.reference,\n      this.tooltipElement,\n      () => this.debouncedUpdate(undefined),\n    );\n\n    const debouncedUpdateHandler = () =>\n      this.debouncedUpdate(undefined) as unknown as EventListenerOrEventListenerObject;\n\n    this.props.updateOnEvents.split(' ').forEach(event => {\n      window.addEventListener(\n        <keyof WindowEventMap>event,\n        debouncedUpdateHandler\n      );\n    });\n    window.addEventListener('click', this.clickHandler.bind(this));\n\n    // prepare event listeners' cleanup method\n    this.updateListenerCleanup = () => {\n      autoUpdateCleanup();\n      window.removeEventListener('click', this.clickHandler.bind(this));\n\n      this.props.updateOnEvents.split(' ').forEach(event => {\n        window.removeEventListener(\n          <keyof WindowEventMap>event,\n          debouncedUpdateHandler\n        );\n      });\n    }\n  }\n\n  private clickHandler = (event: MouseEvent) => {\n    if (!this.state.isShown) return;\n\n    // if click is outside of tooltip and reference\n    if (\n      !this.tooltipElement.contains(event.target as Node) &&\n      !this.reference.contains(event.target as Node)\n    ) {\n      if (this.props.onClickOutside) {\n        this.props.onClickOutside(this, event);\n      }\n    }\n\n    if (this.props.hideOnClick === 'target') {\n      if (event.target === this.reference) {\n        this.hide();\n      }\n    } else if (this.props.hideOnClick) {\n      this.hide();\n    }\n  }\n\n  private updateTransitionDuration(duration: number) {\n    this.transitionDuration = duration;\n    this.tooltipElement.style.transitionDuration = `${duration}ms`;\n  }\n\n  public async create() {\n    const toHide = !this.props.showOnCreate;\n    this.tooltipElement = createTooltipElement(this);\n    this.updateTransitionDuration(\n      this.props.transitionDuration[toHide ? 0 : 1]\n    );\n    const { content: contentBox } = getChildren(this.tooltipElement);\n    const { allowHTML, content } = this.props;\n    if (allowHTML) {\n      contentBox.innerHTML = content;\n    } else {\n      contentBox.innerText = `${content}`;\n    }\n\n    appendTo().appendChild(this.tooltipElement);\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      true,\n      this.setState.bind(this),\n    );\n    this.hookEventListeners();\n  }\n\n  public getState(): TooltipState {\n    return this.state;\n  }\n\n  private setState(newState: Partial<TooltipState>) {\n    const visibilityChanged = typeof newState.isShown !== 'undefined' &&\n      newState.isShown !== this.state.isShown;\n\n    if (visibilityChanged) {\n      this.updateTransitionDuration(\n        this.props.transitionDuration[newState.isShown ? 1 : 0]\n      );\n    }\n\n    this.props.onStateChange(this.state, newState);\n\n    this.state = {\n      ...this.state,\n      ...newState\n    }\n  }\n\n  public async update(toHide?: boolean) {\n    toHide = toHide || this.toHideTooltip || false;\n    await floatingUITooltip(\n      this.props,\n      this.tooltipElement,\n      this.reference,\n      toHide,\n      false,\n      this.setState.bind(this)\n    );\n  }\n\n  public async hide() {\n    // hide() when tooltip is already hidden should prevent event listeners\n    // from showing tooltip without before running show() manually\n    this.toHideTooltip = true;\n    await this.update(true);\n  }\n\n  public async show() {\n    this.toHideTooltip = false;\n    await this.update(false);\n  }\n\n  public remove() {\n    this.tooltipElement.remove();\n    this.state = {\n      isShown: false,\n      isRemoved: true,\n      fui: undefined\n    }\n    this.updateListenerCleanup();\n    console.log('removed all event listeners and observers');\n    this.props.onRemove();\n  }\n}\n\nasync function createTooltip(\n  reference: HTMLElement,\n  props: Partial<Props>\n): Promise<Instance> {\n  const placement = props.placement || defaultProps.placement;\n  const transitionDuration = props.transitionDuration || defaultProps.transitionDuration;\n  const offset = props.offset || defaultProps.offset;\n\n  // NOTE: Interesting that the properties with undefined values still won't be replaced...\n  // -- Relevant to Lusift?\n\n  // remove properties with value of undefined\n  Object.keys(props).forEach(key => props[key] === undefined && delete props[key])\n\n  const allProps: Props = {\n    ...defaultProps,\n    ...props,\n    placement: <Props['placement']>placement,\n    transitionDuration: <Props['transitionDuration']>transitionDuration,\n    offset: <Props['offset']>offset,\n  };\n  const tooltipInstance = new Tooltip(allProps, reference);\n  await tooltipInstance.create();\n\n  const instance: Instance = {\n    props: tooltipInstance.props,\n    reference: tooltipInstance.reference,\n    tooltipElement: tooltipInstance.tooltipElement,\n    getState: tooltipInstance.getState.bind(tooltipInstance),\n    show: tooltipInstance.show.bind(tooltipInstance),\n    hide: tooltipInstance.hide.bind(tooltipInstance),\n    remove: tooltipInstance.remove.bind(tooltipInstance),\n    update: tooltipInstance.update.bind(tooltipInstance),\n  }\n\n  return instance;\n}\n\nexport default createTooltip;\n","import css from './css/style.css';\n\nconst addCSS = () => {\n\n  const defaultStyle = document.createElement(\"style\");\n  defaultStyle.type = \"text/css\";\n  defaultStyle.setAttribute(\"floating-ui-tooltip-default\", \"\");\n  defaultStyle.textContent = css;\n\n  document.head.appendChild(defaultStyle);\n}\n\nexport default addCSS;\n","function debounce<T>(\n  fn: (arg: T) => void,\n  ms: number\n): (arg: T) => void {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  let timeout: any;\n\n  return (arg): void => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => {\n      fn(arg);\n    }, ms);\n  };\n}\n\nexport default debounce;\n"],"names":["updateTransitionEndListener","root","action","listener","method","forEach","event","setTransitionState","element","state","setAttribute","console","log","setElementVisibility","tooltipElement","newVisibilityState","Object","assign","style","visibility","div","document","createElement","getChildren","box","querySelector","content","arrow","undefined","setTooltipVisibility","instance","currentTransitionState","getAttribute","props","onHide","newTransitionState","transitionDuration","callback","e","target","err","error","onTransitionEnd","setState","isShown","setTooltipVisibilityState","onShow","TIP_SIDES_MAP","top","right","bottom","left","floatingUITooltip","tooltipProps","toHide","newlyShown","toShift","_c","passedPlacement","hideOnReferenceHidden","passedOffset","hideOnTooltipEscape","arrowSizeScale","resetPlacementOnUpdate","toShowArrow","scrollIntoView","showOnCreate","arrowElement","TIP_SIZE","position","_a","fui","orientation","x","y","getPosition","toEnableAutoPlacement","toEnableShift","computePositionConfig","placement","middleware","offset","mainAxis","crossAxis","autoPlacement","shift","padding","size","apply","hide","computePosition","_f","middlewareData","_d","referenceHidden","escaped","behavior","block","inline","arrowX","arrowY","arrowOffCenter","centerOffset","staticSide","split","staticSideTipSizeMultiplier","defaultProps","allowHTML","hideOnClick","onClickOutside","onStateChange","oldState","newState","onRemove","maxWidth","updateDebounce","zIndex","updateOnEvents","defaultStyle","this","isRemoved","_this","contains","reference","type","textContent","head","appendChild","toHideTooltip","Tooltip","fn","ms","timeout","debouncedUpdate","update","bind","arg","clearTimeout","setTimeout","autoUpdateCleanup","autoUpdate","debouncedUpdateHandler","window","addEventListener","clickHandler","updateListenerCleanup","removeEventListener","duration","instanceEnv","tooltipRoot","tooltipBox","tooltipContent","className","NODE_CLASSNAME_PREFIX","innerHTML","updateTransitionDuration","contentBox","innerText","body","_b","hookEventListeners","remove","keys","key","allProps","tooltipInstance","create","getState","show"],"mappings":"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"}